using ArchitectureLibrary.Model;
using GBATool.Enums;
using GBATool.FileSystem;
using GBATool.Models;
using GBATool.Utils;
using GBATool.Utils.Image;
using GBATool.VOs;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Media;
using System.Windows.Media.Imaging;

namespace GBATool.Building;

using TileBlocks = (int width, int height, int numberOfTiles);

public sealed class BuildMemoryBanksButano : Building<BuildMemoryBanksButano>
{
    private string[]? _outputPaths;
    protected override OutputFormat OutputFormat { get; } = OutputFormat.Butano;
    protected override string[] OutputPaths
    {
        get
        {
            if (_outputPaths == null)
            {
                _outputPaths = new string[1];
                ProjectModel projectModel = ModelManager.Get<ProjectModel>();
                _outputPaths[0] = projectModel.Build.GeneratedHeadersPath;
            }

            return _outputPaths;
        }
    }

    protected override async Task<bool> DoGenerate()
    {
        string outputPath = Path.GetFullPath(OutputPaths[0]);

        List<FileModelVO> bankModelVOs = ProjectFiles.GetModels<BankModel>();

        int processedCount = 0;

        foreach (FileModelVO vo in bankModelVOs)
        {
            if (vo.Model is not BankModel bank)
            {
                continue;
            }

            if (string.IsNullOrEmpty(vo.Name))
            {
                continue;
            }

            if (bank.BitsPerPixel == BitsPerPixel.f1bpp)
            {
                AddWarning($"1BPP not supported for banks exporting at the moment.");
                continue;
            }

            string fileName = Path.Combine(outputPath, "bank_" + vo.Name.ToLower());

            using StreamWriter outputFile = new(Path.Combine(fileName + ".h"));

            await WriteHeader(outputFile, vo.Name);
            await WriteFileContent(outputFile, bank, vo.Name);
            await WriteFooter(outputFile, vo.Name);

            processedCount++;
        }

        if (processedCount == 0)
        {
            AddError("No banks processed");
        }

        return GetErrors().Length == 0;
    }

    private static async Task WriteHeader(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#ifndef GBATOOL_BANK_{name.ToUpper()}");
        await outputFile.WriteLineAsync($"#define GBATOOL_BANK_{name.ToUpper()}");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"bn_sprite_item.h\"");

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private static async Task WriteFooter(StreamWriter outputFile, string name)
    {
        await outputFile.WriteLineAsync($"#endif // GBATOOL_BANK_{name.ToUpper()}");
    }

    private async Task WriteFileContent(StreamWriter outputFile, BankModel bank, string name)
    {
        TileBlocks cellsCount = bank.GetBoundingBoxSize();

        int imageWidth = cellsCount.width * BankUtils.SizeOfCellInPixels;
        int imageHeight = cellsCount.height * BankUtils.SizeOfCellInPixels;

        BankImageMetaData metaData = BankUtils.CreateImage(bank, false, imageWidth, imageHeight);

        if (metaData.image == null)
        {
            return;
        }

        List<Color> palette = [];

        bool ret = BankUtils.GetPaletteIfExistInCharacters(bank, ref palette);

        if (!ret)
        {
            AddWarning($"No palette configure for bank [{name}], is going to be skipped");
            return;
        }

        foreach (SpriteModel sprite in metaData.bankSprites)
        {
            KeyValuePair<string, SpriteInfo> spriteInfo = metaData.Sprites.First(x => x.Key == sprite.ID);

            if (spriteInfo.Value.BitmapSource == null)
            {
                continue;
            }

            int width = 0;
            int height = 0;
            SpriteUtils.ConvertToWidthHeight(sprite.Shape, sprite.Size, ref width, ref height);

            List<(int, string, string)> indices = metaData.SpriteIndices.FindAll(x => x.Item2 == sprite.ID);

            TileBlocks tileBlicks = new()
            {
                numberOfTiles = indices.Count,
                width = width / 8,
                height = height / 8,
            };

            byte[]? imageData = null;
            WriteableBitmap spriteBitmap = new(spriteInfo.Value.BitmapSource);

            try
            {
                List<string> warnings = [];

                imageData = ImageProcessing.ConvertToXbpp(bank.BitsPerPixel, in spriteBitmap, in tileBlicks, in palette, ref warnings);

                foreach (string item in warnings)
                {
                    AddWarning($"{name}, " + item);
                }
            }
            catch (Exception e)
            {
                AddError(e.Message);
                continue;
            }

            if (imageData == null)
            {
                continue;
            }

            List<int> dataWords = [];

            using MemoryStream ms = new(imageData);
            using BinaryReader br = new(ms);

            br.BaseStream.Position = 0;
            while (br.BaseStream.Position < br.BaseStream.Length)
            {
                dataWords.Add(br.ReadInt32());
            }

            string alias = sprite.Alias.Replace('-', '_');
            string tileName = $"{name}_{alias}";

            await outputFile.WriteLineAsync($"#define {tileName}TilesLen {dataWords.Count * (int)bank.BitsPerPixel}");
            await outputFile.WriteLineAsync($"const bn::tile {tileName}Tiles[{dataWords.Count / 8}] =");
            await outputFile.WriteLineAsync("{");

            int count = 0;
            int countLines = 0;

            foreach (int data in dataWords)
            {
                if (count % 8 == 0)
                {
                    await outputFile.WriteAsync("    ");
                }

                await outputFile.WriteAsync($"0x{data:X8}");

                if (count < dataWords.Count - 1)
                {
                    await outputFile.WriteAsync(", ");
                }

                count++;

                if (count % 8 == 0)
                {
                    await outputFile.WriteAsync(Environment.NewLine);

                    countLines++;
                }

                if (countLines == 8 && count < dataWords.Count - 1)
                {
                    await outputFile.WriteAsync(Environment.NewLine);
                    countLines = 0;
                }
            }

            await outputFile.WriteLineAsync("};");
            await outputFile.WriteAsync(Environment.NewLine);
        }
    }
}
