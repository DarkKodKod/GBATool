using ArchitectureLibrary.Model;
using GBATool.Enums;
using GBATool.FileSystem;
using GBATool.Models;
using GBATool.Utils;
using GBATool.Utils.Image;
using GBATool.VOs;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Media;
using System.Windows.Media.Imaging;

namespace GBATool.Building;

using TileBlocks = (int width, int height, int numberOfTiles);

public sealed class BuildMemoryBanksButano : Building<BuildMemoryBanksButano>
{
    protected override string FileName { get; } = string.Empty;
    protected override OutputFormat OutputFormat { get; } = OutputFormat.Butano;

    protected override async Task<bool> DoGenerate()
    {
        ProjectModel projectModel = ModelManager.Get<ProjectModel>();

        string outputPath = Path.GetFullPath(projectModel.Build.GeneratedAssetsPath);

        List<FileModelVO> bankModelVOs = ProjectFiles.GetModels<BankModel>();

        int processedCount = 0;

        foreach (FileModelVO vo in bankModelVOs)
        {
            if (vo.Model is not BankModel bank)
            {
                continue;
            }

            if (string.IsNullOrEmpty(vo.Name))
            {
                continue;
            }

            string fileName = Path.Combine(outputPath, "bank_" + vo.Name.ToLower());

            using StreamWriter outputFile = new(Path.Combine(fileName + ".h"));

            await WriteHeader(outputFile, vo.Name);
            await WriteFileContent(outputFile, bank, vo.Name);
            await WriteFooter(outputFile, vo.Name);

            processedCount++;
        }

        if (processedCount == 0)
        {
            AddError("No banks processed");
        }

        return GetErrors().Length == 0;
    }

    private static async Task WriteHeader(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#ifndef GBATOOL_SPRITE_{name.ToUpper()}");
        await outputFile.WriteLineAsync($"#define GBATOOL_SPRITE_{name.ToUpper()}");

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private static async Task WriteFooter(StreamWriter outputFile, string name)
    {
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#endif // GBATOOL_SPRITE_{name.ToUpper()}");
    }

    private async Task WriteFileContent(StreamWriter outputFile, BankModel bank, string name)
    {
        BitsPerPixel bpp = bank.Use256Colors ? BitsPerPixel.f8bpp : BitsPerPixel.f4bpp;

        TileBlocks cellsCount = bank.GetBoundingBoxSize();

        int imageWidth = cellsCount.width * BankUtils.SizeOfCellInPixels;
        int imageHeight = cellsCount.height * BankUtils.SizeOfCellInPixels;

        BankImageMetaData metaData = BankUtils.CreateImage(bank, false, imageWidth, imageHeight);

        if (metaData.image == null)
        {
            return;
        }

        List<Color> palette = [];

        bool ret = BankUtils.GetPaletteIfExistInCharacters(bank, ref palette);

        if (!ret)
        {
            AddWarning($"No palette configure for bank [{name}], is going to be skipped");
            return;
        }

        foreach (SpriteRef spriteRef in bank.Sprites)
        {
            if (string.IsNullOrEmpty(spriteRef.SpriteID) || string.IsNullOrEmpty(spriteRef.TileSetID))
            {
                continue;
            }

            TileSetModel? tileSetModel = ProjectFiles.GetModel<TileSetModel>(spriteRef.TileSetID);

            if (tileSetModel == null)
            {
                continue;
            }

            SpriteModel? sprite = tileSetModel.Sprites.Find((item) => item.ID == spriteRef.SpriteID);

            if (string.IsNullOrEmpty(sprite?.ID))
            {
                continue;
            }

            KeyValuePair<string, SpriteInfo> spriteInfo = metaData.Sprites.First(x => x.Key == sprite.ID);

            if (spriteInfo.Value.BitmapSource == null)
            {
                continue;
            }
            
            byte[]? imageData = null;
            WriteableBitmap spriteBitmap = new (spriteInfo.Value.BitmapSource);

            try
            {
                List<string> warnings = [];

                imageData = ImageProcessing.ConvertToXbpp(bpp, in spriteBitmap, in cellsCount, in palette, ref warnings);

                foreach (string item in warnings)
                {
                    AddWarning($"{name}, " + item);
                }
            }
            catch (Exception e)
            {
                AddError(e.Message);
                continue;
            }

            await outputFile.WriteAsync("");
        }
    }
}
