using ArchitectureLibrary.Model;
using GBATool.Enums;
using GBATool.FileSystem;
using GBATool.Models;
using GBATool.Utils;
using GBATool.VOs;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace GBATool.Building;

public sealed class BuildMetaSpritesButano : Building<BuildMetaSpritesButano>
{
    private struct SpriteDetails
    {
        public string SpriteName;
        public string SpriteShape;
        public string SpriteSize;
    }

    private struct AnimationDetails
    {
        public string Name;
        public string BankName;
        public string Tiles;
        public string TilesSize;
        public string BppMode;
        public string Palette;
        public string PaletteSize;
        public List<SpriteDetails> Animations;
    }

    protected override string FileName { get; } = string.Empty;
    protected override OutputFormat OutputFormat { get; } = OutputFormat.Butano;

    protected override async Task<bool> DoGenerate()
    {
        ProjectModel projectModel = ModelManager.Get<ProjectModel>();

        List<FileModelVO> models = ProjectFiles.GetModels<CharacterModel>();

        foreach (FileModelVO item in models)
        {
            if (item.Model is not CharacterModel model)
            {
                continue;
            }

            if (string.IsNullOrEmpty(item.Name))
            {
                continue;
            }

            string parentFolder = Path.GetFullPath(projectModel.Build.GeneratedAssetsPath);

            using StreamWriter outputFile = new(Path.Combine(parentFolder, item.Name + ".h"));

            await WriteSpriteFile(outputFile, model, item.Name);
        }

        return GetErrors().Length == 0;
    }

    private static async Task WriteSpriteFile(StreamWriter outputFile, CharacterModel model, string name)
    {
        await WriteHeader(outputFile, name);
        await WriteSpritesDeclarations(outputFile, model);
        await WriteClass(outputFile, name);
        await WriteFooter(outputFile, name);
    }

    private static async Task WriteFooter(StreamWriter outputFile, string name)
    {
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#endif // GBATOOL_SPRITE_{name.ToUpper()}");
    }

    private static async Task WriteHeader(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#ifndef GBATOOL_SPRITE_{name.ToUpper()}");
        await outputFile.WriteLineAsync($"#define GBATOOL_SPRITE_{name.ToUpper()}");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"bn_sprite_item.h\"");
        await outputFile.WriteLineAsync("#include \"bn_array.h\"");
        await outputFile.WriteLineAsync("#include \"bn_vector.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_builder.h\"");

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private static async Task WriteSpritesDeclarations(StreamWriter outputFile, CharacterModel model)
    {
        List<AnimationDetails> declarations = [];

        foreach (KeyValuePair<string, CharacterAnimation> animationItem in model.Animations)
        {
            CharacterAnimation animation = animationItem.Value;

            if (string.IsNullOrEmpty(animation.ID))
            {
                continue;
            }

            foreach (KeyValuePair<string, FrameModel> frameItem in animation.Frames)
            {
                FrameModel frameModel = frameItem.Value;

                BankModel? bankModel = ProjectFiles.GetModel<BankModel>(frameModel.BankID);

                if (bankModel == null)
                {
                    continue;
                }

                FileModelVO? fileModelBankVO = ProjectFiles.GetFileModel(bankModel.GUID);
                if (fileModelBankVO == null)
                {
                    continue;
                }

                string bankName = fileModelBankVO.Name ?? "";

                string bppMode = bankModel.Use256Colors ? "bpp_mode::BPP_8" : "bpp_mode::BPP_4";

                string tiles = "tank_base_bn_gfxTiles";
                string tilesSize = "144";
                string palette = "tank_base_bn_gfxPal";
                string paletteSize = bankModel.Use256Colors ? "256" : "16";

                List<SpriteDetails> spriteDetails = [];

                foreach (KeyValuePair<string, CharacterSprite> tileItem in frameModel.Tiles)
                {
                    CharacterSprite characterSprite = tileItem.Value;

                    TileSetModel? tileSetModel = ProjectFiles.GetModel<TileSetModel>(characterSprite.TileSetID);

                    if (tileSetModel == null)
                    {
                        continue;
                    }

                    SpriteModel? spriteModel = tileSetModel.Sprites.Find((item) => item.ID == characterSprite.SpriteID);

                    if (spriteModel == null)
                    {
                        continue;
                    }

                    string alias = spriteModel.Alias.Replace('-', '_');

                    string spriteName = $"{bankName}_{alias}";

                    SpriteShape shape = SpriteShape.Shape00;
                    SpriteSize size = SpriteSize.Size00;

                    SpriteUtils.ConvertToShapeSize(characterSprite.Width, characterSprite.Height, ref shape, ref size);

                    string spriteShape = "";

                    switch (shape)
                    {
                        case SpriteShape.Shape00: spriteShape = "sprite_shape::SQUARE"; break;
                        case SpriteShape.Shape01: spriteShape = "sprite_shape::WIDE"; break;
                        case SpriteShape.Shape10: spriteShape = "sprite_shape::TALL"; break;
                    }

                    string spriteSize = "";

                    switch (size)
                    {
                        case SpriteSize.Size00: spriteSize = "sprite_size::SMALL"; break;
                        case SpriteSize.Size01: spriteSize = "sprite_size::NORMAL"; break;
                        case SpriteSize.Size10: spriteSize = "sprite_size::BIG"; break;
                        case SpriteSize.Size11: spriteSize = "sprite_size::HUGE"; break;
                    }

                    spriteDetails.Add(new SpriteDetails()
                    {
                        SpriteName = spriteName,
                        SpriteShape = spriteShape,
                        SpriteSize = spriteSize
                    });
                }

                declarations.Add(new AnimationDetails()
                {
                    Name = animation.Name,
                    BankName = bankName,
                    Animations = spriteDetails,
                    Tiles = tiles,
                    TilesSize = tilesSize,
                    BppMode = bppMode,
                    Palette = palette,
                    PaletteSize = paletteSize
                });
            }
        }

        foreach (AnimationDetails item in declarations)
        {
            await outputFile.WriteLineAsync($"#include \"bank_{item.BankName}.h\"");
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("namespace bn::sprite_items");
        await outputFile.WriteLineAsync("{");

        int frameIndex = 0;

        foreach (AnimationDetails animation in declarations)
        {
            await outputFile.WriteLineAsync($"    // {animation.Name}_frame_{frameIndex}");

            foreach (SpriteDetails item in animation.Animations)
            {
                await outputFile.WriteLineAsync($"    constexpr inline sprite_item {item.SpriteName}(sprite_shape_size({item.SpriteShape}, {item.SpriteSize}),");
                await outputFile.WriteLineAsync($"           sprite_tiles_item(span<const tile>({animation.Tiles}, {animation.TilesSize}), {animation.BppMode}, compression_type::NONE, 1),");
                await outputFile.WriteLineAsync($"           sprite_palette_item(span<const color>({animation.Palette}, {animation.PaletteSize}), {animation.BppMode}, compression_type::NONE));");
            }

            frameIndex++;

            if (frameIndex < declarations.Count)
            {
                await outputFile.WriteAsync(Environment.NewLine);
            }
        }

        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
    }

    private static async Task WriteClass(StreamWriter outputFile, string name)
    {
        string className = name.ToCamelCase();

        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"class {className}");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("public:");
        await outputFile.WriteLineAsync($"   {className}(const bn::fixed_point& position,");
        await outputFile.WriteLineAsync("       const bn::camera_ptr& camera) :");
        await outputFile.WriteLineAsync("       _position(position)");
        await outputFile.WriteLineAsync("   {");
        await outputFile.WriteLineAsync("       _sprites.push_back(create_sprite(bn::sprite_items::gato, 20, 50, camera));");
        await outputFile.WriteLineAsync("       _sprites.push_back(create_sprite(bn::sprite_items::gato, 30, 30, camera));");
        await outputFile.WriteLineAsync("       _sprites.push_back(create_sprite(bn::sprite_items::gato, 4, 15, camera));");
        await outputFile.WriteLineAsync("   }");
        await outputFile.WriteLineAsync("   void set_position(int x, int y)");
        await outputFile.WriteLineAsync("   {");
        await outputFile.WriteLineAsync("       bn::fixed_point position(x, y);");
        await outputFile.WriteLineAsync("       set_position(position);");
        await outputFile.WriteLineAsync("   }");
        await outputFile.WriteLineAsync("   void set_position(const bn::fixed_point& position)");
        await outputFile.WriteLineAsync("   {");
        await outputFile.WriteLineAsync("       _position = position;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("       for (bn::sprite_ptr& sprite : _sprites)");
        await outputFile.WriteLineAsync("       {");
        await outputFile.WriteLineAsync("           sprite.set_position(sprite.position() + position);");
        await outputFile.WriteLineAsync("       }");
        await outputFile.WriteLineAsync("   }");
        await outputFile.WriteLineAsync("   [[nodiscard]] const bn::fixed_point& position() const");
        await outputFile.WriteLineAsync("   {");
        await outputFile.WriteLineAsync("       return _position;");
        await outputFile.WriteLineAsync("   }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("protected:");
        await outputFile.WriteLineAsync("   bn::vector<bn::sprite_ptr, 3> _sprites;");
        await outputFile.WriteLineAsync("   bn::fixed_point _position;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("private:");
        await outputFile.WriteLineAsync("   [[nodiscard]] bn::sprite_ptr create_sprite(const bn::sprite_item& spriteItem, bn::fixed x, bn::fixed y, const bn::camera_ptr& camera)");
        await outputFile.WriteLineAsync("   {");
        await outputFile.WriteLineAsync("       bn::sprite_builder builder(spriteItem, 0);");
        await outputFile.WriteLineAsync("       builder.set_x(x);");
        await outputFile.WriteLineAsync("       builder.set_y(y);");
        await outputFile.WriteLineAsync("       builder.set_bg_priority(2);");
        await outputFile.WriteLineAsync("       builder.set_camera(camera);");
        await outputFile.WriteLineAsync("       return builder.release_build();");
        await outputFile.WriteLineAsync("   }");

        await outputFile.WriteLineAsync("};");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("}");
    }
}
