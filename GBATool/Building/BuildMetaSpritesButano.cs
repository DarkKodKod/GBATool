using ArchitectureLibrary.Model;
using GBATool.Enums;
using GBATool.FileSystem;
using GBATool.Models;
using GBATool.Utils;
using GBATool.VOs;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace GBATool.Building;

using FrameDetail = (int starts, int ends);
using SpriteDetail = (string spriteName, int xpos, int ypos, int flippedX);

public sealed class BuildMetaSpritesButano : Building<BuildMetaSpritesButano>
{
    private struct SpriteDetails
    {
        public string SpriteName;
        public string SpriteShape;
        public string SpriteSize;
        public string Tiles;
        public string TilesSize;
        public int posX;
        public int posY;
        public int FlippedPosX;
    }

    private struct FrameDetails
    {
        public string Name;
        public string BankName;
        public string BppMode;
        public string Palette;
        public string PaletteSize;
        public bool HeldFrame;
        public List<SpriteDetails> Sprites;
        public List<CollisionDetails> Collisions;
    }

    private struct AnimationDetails
    {
        public string Name;
        public float Speed;
        public int Priority;
        public bool Looping;
        public int Repeats;
        public List<FrameDetails> Frames;
    }

    private struct CollisionDetails
    {
        public int PosX;
        public int PosY;
        public int Width;
        public int Height;
        public CollisionMask Mask;
        public int CustomMask;
    }

    private struct AllCharactersDetails
    {
        public List<int> CustomMasks;
    }

    protected override OutputFormat OutputFormat { get; } = OutputFormat.Butano;

    private const float FrameRate = 59.727500569606f;
    private string[]? _outputPaths;
    private readonly List<AnimationDetails> _animationDetails = [];

    protected override string[] OutputPaths
    {
        get
        {
            if (_outputPaths == null)
            {
                _outputPaths = new string[2];

                ProjectModel projectModel = ModelManager.Get<ProjectModel>();

                _outputPaths[0] = projectModel.Build.GeneratedHeadersPath;
                _outputPaths[1] = projectModel.Build.GeneratedCPPsPath;
            }

            return _outputPaths;
        }
    }

    protected override async Task<bool> DoGenerate()
    {
        string headerFolder = Util.GetAbsolutePathFromRelativeToProject(OutputPaths[0]);
        string cppFolder = Util.GetAbsolutePathFromRelativeToProject(OutputPaths[1]);

        List<FileModelVO> models = ProjectFiles.GetModels<CharacterModel>();

        AllCharactersDetails allCharacterDetails = new()
        {
            CustomMasks =
                (from item in models
                 where !string.IsNullOrEmpty(item.Name)
                 let model = item.Model
                 where model is CharacterModel
                 from animation in ((CharacterModel)model).Animations.Values
                 from frame in animation.Frames.Values
                 from collision in frame.CollisionInfo.Values
                 where collision.Mask == (int)CollisionMask.Custom
                 select collision.CustomMask).Distinct().Order().ToList()
        };

        {
            using StreamWriter outputBaseFileHeader = new(Path.Combine(headerFolder, "character.h"));
            using StreamWriter outputBaseFileCpp = new(Path.Combine(cppFolder, "character.cpp"));

            await WriteCharacterBaseClassHeader(outputBaseFileHeader, allCharacterDetails);
            await WriteCharacterBaseClassCpp(outputBaseFileCpp);
        }

        foreach (FileModelVO item in models)
        {
            if (item.Model is not CharacterModel model)
            {
                continue;
            }

            if (string.IsNullOrEmpty(item.Name))
            {
                continue;
            }

            _animationDetails.Clear();

            using StreamWriter outputFileHeader = new(Path.Combine(headerFolder, item.Name + ".h"));

            await WriteSpriteFileHeader(outputFileHeader, model, item.Name);

            using StreamWriter outputFileCpp = new(Path.Combine(cppFolder, item.Name + ".cpp"));

            await WriteSpriteFileCpp(outputFileCpp, allCharacterDetails, item.Name);
        }

        return GetErrors().Length == 0;
    }

    private async Task WriteSpriteFileHeader(StreamWriter outputFile, CharacterModel model, string name)
    {
        await WriteHeader(outputFile, name);
        await WriteBanksAndPalettesHeaders(outputFile, model);
        await WriteClassDeclarations(outputFile, model, name);
        await WriteFooter(outputFile, name);
    }

    private async Task WriteSpriteFileCpp(StreamWriter outputFile, AllCharactersDetails allCharacterDetails, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await WriteClassDefinitions(outputFile, allCharacterDetails, name);
    }

    private static async Task WriteFooter(StreamWriter outputFile, string name)
    {
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#endif // GBATOOL_SPRITE_{name.ToUpper()}");
    }

    private static async Task WriteHeader(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#ifndef GBATOOL_SPRITE_{name.ToUpper()}");
        await outputFile.WriteLineAsync($"#define GBATOOL_SPRITE_{name.ToUpper()}");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"bn_sprite_item.h\"");
        await outputFile.WriteLineAsync("#include \"bn_array.h\"");
        await outputFile.WriteLineAsync("#include \"bn_vector.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_builder.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_ptr.h\"");

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private async Task WriteBanksAndPalettesHeaders(StreamWriter outputFile, CharacterModel characterModel)
    {
        string paletteName = string.Empty;

        PaletteModel? paletteModel = CharacterUtils.GetPaletteUsedByCharacter(characterModel);

        if (paletteModel != null)
        {
            FileModelVO? fileModelPaletteVO = ProjectFiles.GetFileModel(paletteModel.GUID);
            if (fileModelPaletteVO != null && string.IsNullOrEmpty(paletteName))
            {
                paletteName = PaletteUtils.GetPaletteName(fileModelPaletteVO) ?? string.Empty;

                if (paletteModel.LinkedPalettes.Count > 0)
                {
                    string remove = "_Palette_XX";

                    paletteName = paletteName.Replace(paletteName[^remove.Length..], string.Empty); // Removes the "_Palette_XX" from the name
                }
            }
        }

        foreach (KeyValuePair<string, CharacterAnimation> animationItem in characterModel.Animations)
        {
            CharacterAnimation animation = animationItem.Value;

            if (string.IsNullOrEmpty(animation.ID))
            {
                continue;
            }

            List<FrameDetails> frames = [];

            foreach (KeyValuePair<string, FrameModel> frameItem in animation.Frames)
            {
                FrameModel frameModel = frameItem.Value;

                if (frameModel.IsHeldFrame)
                {
                    frames.Add(new FrameDetails()
                    {
                        Name = animation.Name,
                        HeldFrame = true,
                        BankName = string.Empty,
                        Sprites = [],
                        Collisions = [],
                        BppMode = string.Empty,
                        Palette = string.Empty,
                        PaletteSize = string.Empty
                    });
                    continue;
                }

                BankModel? bankModel = ProjectFiles.GetModel<BankModel>(frameModel.BankID);

                if (bankModel == null)
                {
                    continue;
                }

                FileModelVO? fileModelBankVO = ProjectFiles.GetFileModel(bankModel.GUID);
                if (fileModelBankVO == null)
                {
                    continue;
                }

                string bankName = fileModelBankVO.Name ?? "";
                string bppMode = bankModel.BitsPerPixel == BitsPerPixel.f8bpp ? "bpp_mode::BPP_8" : "bpp_mode::BPP_4";
                string palette = $"{paletteName}Pal";
                string paletteSize = bankModel.BitsPerPixel == BitsPerPixel.f8bpp ? "256" : "16";

                List<SpriteDetails> spriteDetails = [];

                foreach (KeyValuePair<string, CharacterSprite> tileItem in frameModel.Tiles)
                {
                    CharacterSprite characterSprite = tileItem.Value;

                    TileSetModel? tileSetModel = ProjectFiles.GetModel<TileSetModel>(characterSprite.TileSetID);

                    if (tileSetModel == null)
                    {
                        continue;
                    }

                    SpriteModel? spriteModel = tileSetModel.Sprites.Find((item) => item.ID == characterSprite.SpriteID);

                    if (spriteModel == null)
                    {
                        continue;
                    }

                    string alias = spriteModel.Alias.Replace('-', '_');

                    int tileSizeNumber = (characterSprite.Width / 8) * (characterSprite.Height / 8);

                    tileSizeNumber *= (bankModel.BitsPerPixel == BitsPerPixel.f8bpp ? 2 : 1);

                    string spriteName = $"{bankName}_{alias}";
                    string tiles = $"{bankName}_{alias}Tiles";
                    string tilesSize = $"{tileSizeNumber}";

                    int posX = (int)(characterSprite.Position.X - characterModel.RelativeOrigin.X);
                    int posY = (int)(characterSprite.Position.Y - characterModel.RelativeOrigin.Y);

                    int verticalAxis = characterModel.VerticalAxis - (int)characterModel.RelativeOrigin.X;
                    int flippedXPos = verticalAxis - (posX - verticalAxis) - characterSprite.Width;

                    // correct the origin of the metasprite
                    posX += (characterSprite.Width / 2);
                    posY += (characterSprite.Height / 2);
                    flippedXPos += (characterSprite.Width / 2);

                    SpriteShape shape = SpriteShape.Shape00;
                    SpriteSize size = SpriteSize.Size00;

                    SpriteUtils.ConvertToShapeSize(characterSprite.Width, characterSprite.Height, ref shape, ref size);

                    string spriteShape = "";

                    switch (shape)
                    {
                        case SpriteShape.Shape00: spriteShape = "sprite_shape::SQUARE"; break;
                        case SpriteShape.Shape01: spriteShape = "sprite_shape::WIDE"; break;
                        case SpriteShape.Shape10: spriteShape = "sprite_shape::TALL"; break;
                    }

                    string spriteSize = "";

                    switch (size)
                    {
                        case SpriteSize.Size00: spriteSize = "sprite_size::SMALL"; break;
                        case SpriteSize.Size01: spriteSize = "sprite_size::NORMAL"; break;
                        case SpriteSize.Size10: spriteSize = "sprite_size::BIG"; break;
                        case SpriteSize.Size11: spriteSize = "sprite_size::HUGE"; break;
                    }

                    spriteDetails.Add(new SpriteDetails()
                    {
                        SpriteName = spriteName,
                        SpriteShape = spriteShape,
                        SpriteSize = spriteSize,
                        Tiles = tiles,
                        TilesSize = tilesSize,
                        posX = posX,
                        posY = posY,
                        FlippedPosX = flippedXPos
                    });
                }

                List<CollisionDetails> collisionDetails =
                    frameModel.CollisionInfo.Values
                        .OrderBy((coll) => coll.Mask)
                        .ThenBy((coll) => coll.CustomMask)
                        .Select((coll) => new CollisionDetails()
                        {
                            PosX = (int)(coll.PosX - characterModel.RelativeOrigin.X),
                            PosY = (int)(coll.PosY - characterModel.RelativeOrigin.Y),
                            Width = coll.Width,
                            Height = coll.Height,
                            Mask = (CollisionMask)coll.Mask,
                            CustomMask = coll.CustomMask
                        }).ToList();

                frames.Add(new FrameDetails()
                {
                    Name = animation.Name,
                    BankName = bankName,
                    Sprites = spriteDetails,
                    Collisions = collisionDetails,
                    BppMode = bppMode,
                    Palette = palette,
                    HeldFrame = false,
                    PaletteSize = paletteSize
                });
            }

            _animationDetails.Add(
                new AnimationDetails()
                {
                    Name = $"{animation.Name}",
                    Frames = frames,
                    Priority = (int)characterModel.Priority,
                    Looping = animation.Looping,
                    Repeats = animation.Repeat,
                    Speed = animation.Speed
                });
        }

        List<string> includeBankUsed = [];
        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            foreach (FrameDetails item in animationDetail.Frames)
            {
                if (item.HeldFrame)
                    continue;

                if (!includeBankUsed.Contains(item.BankName))
                {
                    await outputFile.WriteLineAsync($"#include \"bank_{item.BankName}.h\"");

                    includeBankUsed.Add(item.BankName);
                }
            }
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#include \"{paletteName}.h\"");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"character.h\"");

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private async Task WriteSpritesDeclarations(StreamWriter outputFile, CharacterModel characterModel)
    {
        await outputFile.WriteLineAsync("public: // Sprite items");

        List<string> alreadyUsedDeclaration = [];

        int countAnimations = 0;

        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            int frameIndex = 0;

            foreach (FrameDetails frame in animationDetail.Frames)
            {
                string heldFrame = frame.HeldFrame ? " - Held Frame" : string.Empty;

                await outputFile.WriteLineAsync($"    // {frame.Name}_frame_{frameIndex + 1}{heldFrame}");

                foreach (SpriteDetails sprite in frame.Sprites)
                {
                    if (!alreadyUsedDeclaration.Exists(x => x == sprite.SpriteName))
                    {
                        await outputFile.WriteLineAsync($"    static constexpr bn::sprite_item {sprite.SpriteName} = bn::sprite_item(");
                        await outputFile.WriteLineAsync($"        bn::sprite_shape_size(bn::{sprite.SpriteShape}, bn::{sprite.SpriteSize}),");
                        await outputFile.WriteLineAsync($"        bn::sprite_tiles_item(bn::span<const bn::tile>({sprite.Tiles}, {sprite.TilesSize}), bn::{frame.BppMode}, bn::compression_type::NONE, 1),");
                        await outputFile.WriteLineAsync($"        bn::sprite_palette_item(bn::span<const bn::color>({frame.Palette}, {frame.PaletteSize}), bn::{frame.BppMode}, bn::compression_type::NONE));");

                        alreadyUsedDeclaration.Add(sprite.SpriteName);
                    }
                    else
                    {
                        await outputFile.WriteLineAsync($"    // sprite_item, {sprite.SpriteName}, already declared in a previous frame");
                    }
                }

                frameIndex++;

                if (frameIndex < animationDetail.Frames.Count)
                {
                    await outputFile.WriteAsync(Environment.NewLine);
                }
            }

            countAnimations++;

            if (countAnimations < _animationDetails.Count)
            {
                await outputFile.WriteAsync(Environment.NewLine);
            }
        }

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private async Task WriteClassDeclarations(StreamWriter outputFile, CharacterModel model, string name)
    {
        string className = name.ToCamelCase();

        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync($"    class {className};");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"class gbatool::{className} : public Character");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("public:");
        await outputFile.WriteLineAsync("    enum AnimationID");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        NONE = Character::AnimationID::NONE");

        int numberMaxSpritesPerFrame = 0;
        int countSpritesTotal = 0;
        int countFramesTotal = 0;

        for (int i = 0; i < _animationDetails.Count; ++i)
        {
            await outputFile.WriteLineAsync($"        , {_animationDetails[i].Name.ToUpper()} = {i}");

            foreach (FrameDetails frame in _animationDetails[i].Frames)
            {
                if (frame.Sprites.Count > numberMaxSpritesPerFrame)
                {
                    numberMaxSpritesPerFrame = frame.Sprites.Count;
                }

                countSpritesTotal += frame.Sprites.Count;
                countFramesTotal++;
            }
        }

        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"    {className}();");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("protected:");
        await outputFile.WriteLineAsync($"    bn::vector<bn::sprite_ptr, {numberMaxSpritesPerFrame}> _frameSprites;");
        await outputFile.WriteAsync(Environment.NewLine);
        await WriteSpritesDeclarations(outputFile, model);
        await outputFile.WriteLineAsync("};");
    }

    private async Task WriteClassDefinitions(StreamWriter outputFile, AllCharactersDetails allCharacterDetails, string name)
    {
        List<SpriteDetail> sprites = [];
        List<FrameDetail> frames = [];

        int acumSprites = 0;

        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            foreach (FrameDetails frame in animationDetail.Frames)
            {
                foreach (SpriteDetails sprite in frame.Sprites)
                {
                    sprites.Add((sprite.SpriteName, sprite.posX, sprite.posY, sprite.FlippedPosX));

                    acumSprites++;
                }

                if (frame.HeldFrame)
                {
                    frames.Add((-1, -1));
                }
                else
                {
                    frames.Add((acumSprites - frame.Sprites.Count, acumSprites - 1));
                }
            }
        }

        string className = name.ToCamelCase();

        await outputFile.WriteLineAsync($"#include \"{name}.h\"");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteAsync($"static constexpr {className}::Animation animations[{_animationDetails.Count}] = ");
        await outputFile.WriteAsync("{");

        for (int i = 0; i < _animationDetails.Count; ++i)
        {
            int frameDuration = (int)(_animationDetails[i].Speed * FrameRate);
            int repeats = _animationDetails[i].Looping ? 0 : _animationDetails[i].Repeats;

            await outputFile.WriteAsync($"{{{_animationDetails[i].Frames.Count}, {frameDuration}, {repeats}}}");

            if (i < _animationDetails.Count - 1)
                await outputFile.WriteAsync(", ");
        }

        await outputFile.WriteLineAsync("};");
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteAsync($"static constexpr {className}::Frame frames[{frames.Count}] = ");
        await outputFile.WriteAsync("{");

        for (int i = 0; i < frames.Count; ++i)
        {
            await outputFile.WriteAsync($"{{{frames[i].starts}, {frames[i].ends}}}");

            if (i < frames.Count - 1)
                await outputFile.WriteAsync(", ");
        }

        await outputFile.WriteLineAsync("};");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"static constexpr {className}::Sprite sprites[{sprites.Count}] = {{");

        for (int i = 0; i < sprites.Count; ++i)
        {
            await outputFile.WriteAsync($"    {{ &{className}::{sprites[i].spriteName}, {sprites[i].xpos}, {sprites[i].ypos}, {sprites[i].flippedX} }}");

            if (i < sprites.Count - 1)
                await outputFile.WriteAsync(",");

            await outputFile.WriteAsync(Environment.NewLine);
        }

        await outputFile.WriteLineAsync("};");

        await outputFile.WriteAsync(Environment.NewLine);

        List<string> animCollisionsNames = [];

        int animIdx = 0;
        foreach (AnimationDetails animationDetails in _animationDetails)
        {
            List<string> frameCollisionsNames = [];

            int frameIdx = 0;
            foreach (FrameDetails frameDetails in animationDetails.Frames)
            {
                const string EmptySpan = "bn::span<const Character::Collisions::RelativeRect>{}";
                List<string> maskCollisionsNames = [EmptySpan, EmptySpan, .. allCharacterDetails.CustomMasks.Select((_) => EmptySpan)];

                int lastMask = -1;
                int? lastCustomMask = null;

                foreach (CollisionDetails collisionDetails in frameDetails.Collisions)
                {
                    if ((collisionDetails.Mask < CollisionMask.Custom && (int)collisionDetails.Mask != lastMask) ||
                        (collisionDetails.Mask == CollisionMask.Custom && collisionDetails.CustomMask != lastCustomMask))
                    {
                        if (lastMask != -1)
                        {
                            await outputFile.WriteLineAsync("};");
                            await outputFile.WriteAsync(Environment.NewLine);
                        }

                        StringBuilder maskCollisionsNameBuilder = new();
                        maskCollisionsNameBuilder.Append($"{frameDetails.Name}_frame_{frameIdx}_mask_");
                        if (collisionDetails.Mask == CollisionMask.Custom)
                        {
                            maskCollisionsNameBuilder.Append("custom_");
                            if (collisionDetails.CustomMask < 0)
                                maskCollisionsNameBuilder.Append($"minus_{-collisionDetails.CustomMask}");
                            else
                                maskCollisionsNameBuilder.Append(collisionDetails.CustomMask);
                        }
                        else if (collisionDetails.Mask == CollisionMask.Hitbox)
                        {
                            maskCollisionsNameBuilder.Append("hitbox");
                        }
                        else if (collisionDetails.Mask == CollisionMask.Hurtbox)
                        {
                            maskCollisionsNameBuilder.Append("hurtbox");
                        }
                        maskCollisionsNameBuilder.Append("_collisions");

                        string maskCollisionsName = maskCollisionsNameBuilder.ToString();
                        int maskCollisionsNamesIdx = (collisionDetails.Mask == CollisionMask.Custom) ? 2 + allCharacterDetails.CustomMasks.IndexOf(collisionDetails.CustomMask) :
                            (collisionDetails.Mask == CollisionMask.Hurtbox) ? 1 : 0;
                        maskCollisionsNames[maskCollisionsNamesIdx] = maskCollisionsName;

                        await outputFile.WriteLineAsync($"static constexpr Character::Collisions::RelativeRect {maskCollisionsName}[] = {{");
                    }

                    await outputFile.WriteLineAsync($"    Character::Collisions::RelativeRect({collisionDetails.PosX}, {collisionDetails.PosY}, {collisionDetails.Width}, {collisionDetails.Height}),");

                    lastMask = (int)collisionDetails.Mask;
                    if (collisionDetails.Mask == CollisionMask.Custom)
                        lastCustomMask = collisionDetails.CustomMask;
                }

                string frameCollisionsName = $"{frameDetails.Name}_frame_{frameIdx}_collisions";
                if (frameDetails.HeldFrame && frameCollisionsNames.Count != 0)
                {
                    frameCollisionsName = frameCollisionsNames[frameCollisionsNames.Count - 1];
                }
                else
                {
                    if (lastMask != -1)
                    {
                        await outputFile.WriteLineAsync("};");
                        await outputFile.WriteAsync(Environment.NewLine);
                    }

                    await outputFile.WriteLineAsync($"static constexpr bn::span<const Character::Collisions::RelativeRect> {frameCollisionsName}_spans[] = {{");
                    foreach (string maskCollisionsName in maskCollisionsNames)
                        await outputFile.WriteLineAsync($"    {maskCollisionsName},");
                    await outputFile.WriteLineAsync("};");
                    await outputFile.WriteAsync(Environment.NewLine);
                    await outputFile.WriteLineAsync($"static constexpr Character::Collisions {frameCollisionsName}({frameCollisionsName}_spans);");

                    await outputFile.WriteAsync(Environment.NewLine);
                }
                frameCollisionsNames.Add(frameCollisionsName);

                ++frameIdx;
            }

            string animCollisionsName = $"{animationDetails.Name}_collisions";
            animCollisionsNames.Add(animCollisionsName);

            if (frameCollisionsNames.Count == 0)
            {
                await outputFile.WriteLineAsync($"static constexpr bn::span<const Character::Collisions> {animCollisionsName};");
            }
            else
            {
                await outputFile.WriteLineAsync($"static constexpr const Character::Collisions {animCollisionsName}[] = {{");
                foreach (string frameCollisionsName in frameCollisionsNames)
                    await outputFile.WriteLineAsync($"    {frameCollisionsName},");
                await outputFile.WriteLineAsync("};");
            }

            await outputFile.WriteAsync(Environment.NewLine);

            ++animIdx;
        }

        if (animCollisionsNames.Count == 0)
        {
            await outputFile.WriteLineAsync($"static constexpr bn::span<const bn::span<const Character::Collisions>> collisions;");
        }
        else
        {
            await outputFile.WriteLineAsync($"static constexpr const bn::span<const Character::Collisions> collisions[] = {{");
            foreach (string animCollisionsName in animCollisionsNames)
                await outputFile.WriteLineAsync($"    {animCollisionsName},");
            await outputFile.WriteLineAsync("};");
        }

        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"{className}::{className}() :");
        await outputFile.WriteLineAsync("    Character(");
        await outputFile.WriteLineAsync($"        bn::span<const {className}::Animation>(animations, {_animationDetails.Count}), ");
        await outputFile.WriteLineAsync($"        bn::span<const {className}::Frame>(frames, {frames.Count}), ");
        await outputFile.WriteLineAsync($"        bn::span<const {className}::Sprite>(sprites, {sprites.Count}),");
        await outputFile.WriteLineAsync("        collisions, _frameSprites");
        await outputFile.WriteLineAsync("    )");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("}");
    }

    private async static Task WriteCharacterBaseClassHeader(StreamWriter outputFile, AllCharactersDetails allCharacterDetails)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#ifndef GBATOOL_CHARACTER");
        await outputFile.WriteLineAsync("#define GBATOOL_CHARACTER");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("#include \"bn_sprite_item.h\"");
        await outputFile.WriteLineAsync("#include \"bn_array.h\"");
        await outputFile.WriteLineAsync("#include \"bn_vector.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_builder.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_ptr.h\"");
        await outputFile.WriteLineAsync("#include \"bn_span.h\"");
        await outputFile.WriteLineAsync("#include \"bn_optional.h\"");
        await outputFile.WriteLineAsync("#include \"bn_top_left_fixed_rect.h\"");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("class Character");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("public:");
        await outputFile.WriteLineAsync("    enum AnimationID");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        NONE = -1");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    enum class Mask : unsigned");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        HITBOX,");
        await outputFile.WriteLineAsync("        HURTBOX,");
        foreach (int customMask in allCharacterDetails.CustomMasks)
        {
            if (customMask >= 0)
                await outputFile.WriteLineAsync($"        CUSTOM_{customMask},");
            else
                await outputFile.WriteLineAsync($"        CUSTOM_MINUS_{-customMask},");
        }
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Animation");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        constexpr Animation(int total, int duration, int rep) :");
        await outputFile.WriteLineAsync("            totalFrames(total)");
        await outputFile.WriteLineAsync("            , frameDuration(duration)");
        await outputFile.WriteLineAsync("            , repeats(rep)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        int totalFrames;");
        await outputFile.WriteLineAsync("        int frameDuration;");
        await outputFile.WriteLineAsync("        int repeats;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Frame");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        constexpr Frame(int starts, int ends) :");
        await outputFile.WriteLineAsync("            spriteStarts(starts)");
        await outputFile.WriteLineAsync("            , spriteEnds(ends)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        int spriteStarts;");
        await outputFile.WriteLineAsync("        int spriteEnds;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Sprite");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        constexpr Sprite(const bn::sprite_item* item, int x, int y, int xFlipped) : ");
        await outputFile.WriteLineAsync("            sprite_item(item)");
        await outputFile.WriteLineAsync("            , position(bn::fixed_point(x, y))");
        await outputFile.WriteLineAsync("            , position_horizontal_flipped(bn::fixed_point(xFlipped, y))");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        const bn::sprite_item* sprite_item;");
        await outputFile.WriteLineAsync("        bn::fixed_point position;");
        await outputFile.WriteLineAsync("        bn::fixed_point position_horizontal_flipped;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    class Collisions");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("    public:");
        await outputFile.WriteLineAsync("        class RelativeRect");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        public:");
        await outputFile.WriteLineAsync("            constexpr RelativeRect(short x, short y, unsigned short width, unsigned short height)");
        await outputFile.WriteLineAsync("                : _x(x), _y(y), _width(width), _height(height)");
        await outputFile.WriteLineAsync("            {");
        await outputFile.WriteLineAsync("            }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("            auto get_absolute_rect(const Character& self) const -> bn::top_left_fixed_rect;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        private:");
        await outputFile.WriteLineAsync("            short _x, _y;");
        await outputFile.WriteLineAsync("            unsigned short _width, _height;");
        await outputFile.WriteLineAsync("        };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        constexpr Collisions(const bn::span<const bn::span<const RelativeRect>>& rects_per_mask)");
        await outputFile.WriteLineAsync("            : _rects_per_mask(rects_per_mask)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        auto get_rects_with_mask(Mask) const -> const bn::span<const RelativeRect>&;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    private:");
        await outputFile.WriteLineAsync("        bn::span<const bn::span<const RelativeRect>> _rects_per_mask;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    virtual ~Character() = default;");
        await outputFile.WriteLineAsync("    void update_animation();");
        await outputFile.WriteLineAsync("    void load_animation(int animation);");
        await outputFile.WriteLineAsync("    void set_position(int x, int y);");
        await outputFile.WriteLineAsync("    void set_position(const bn::fixed_point& position);");
        await outputFile.WriteLineAsync("    void set_camera(const bn::camera_ptr& camera);");
        await outputFile.WriteLineAsync("    void set_priority(int priority);");
        await outputFile.WriteLineAsync("    void set_facing_right(bool facingRight);");
        await outputFile.WriteLineAsync("    void set_frame_counter(int frameCounter);");
        await outputFile.WriteLineAsync("    void set_frame_index(int frameIndex);");
        await outputFile.WriteLineAsync("    void set_z_order(int z_order);");
        await outputFile.WriteLineAsync("    void set_visible(bool visible);");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_facing_right() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_facing_left() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_animation_playing() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_visible() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_id() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_frame_index() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_frame_counter() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_total_frames() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_frame_duration() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_repeats() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] auto current_frame_collisions() const -> const Collisions&;");
        await outputFile.WriteLineAsync("    [[nodiscard]] const bn::fixed_point& position() const;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("protected:");
        await outputFile.WriteLineAsync("    using CollisionsPerFrame = bn::span<const Collisions>;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    Character(const bn::span<const Animation>& animations, const bn::span<const Frame>& frames,");
        await outputFile.WriteLineAsync("        const bn::span<const Sprite>& sprites, const bn::span<const CollisionsPerFrame>& collisions_per_animation,");
        await outputFile.WriteLineAsync("        bn::ivector<bn::sprite_ptr>& currentFrameSprites);");
        await outputFile.WriteLineAsync("    Character(const Character&) = delete;");
        await outputFile.WriteLineAsync("    Character(const Character&&) = delete;");
        await outputFile.WriteLineAsync("    bn::fixed_point _position;");
        await outputFile.WriteLineAsync("    bn::optional<bn::camera_ptr> _camera;");
        await outputFile.WriteLineAsync("    int _currentAnimation;");
        await outputFile.WriteLineAsync("    int _frameCounter;");
        await outputFile.WriteLineAsync("    int _frameIndex;");
        await outputFile.WriteLineAsync("    int _priority;");
        await outputFile.WriteLineAsync("    int _z_order;");
        await outputFile.WriteLineAsync("    int _animation_repeats;");
        await outputFile.WriteLineAsync("    bool _facingRight;");
        await outputFile.WriteLineAsync("    bool _visible;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("private:");
        await outputFile.WriteLineAsync("    [[nodiscard]] bn::optional<bn::sprite_ptr> create_sprite(unsigned int spriteIndex);");
        await outputFile.WriteLineAsync("    void load_next_frame();");
        await outputFile.WriteLineAsync("    void load_current_frame(bool forceReload);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    bn::span<const Animation> _animations;");
        await outputFile.WriteLineAsync("    bn::span<const Frame> _frames;");
        await outputFile.WriteLineAsync("    bn::span<const Sprite> _sprites;");
        await outputFile.WriteLineAsync("    bn::span<const CollisionsPerFrame> _collisions_per_animation;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    bn::ivector<bn::sprite_ptr>& _currentFrameSprites;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    int _current_sprite_start_index;");
        await outputFile.WriteLineAsync("    bool _animation_running;");
        await outputFile.WriteLineAsync("};");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("#endif // GBATOOL_CHARACTER");
    }

    private async static Task WriteCharacterBaseClassCpp(StreamWriter outputFile)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"character.h\"");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("Character::Character(const bn::span<const Animation>& animations, const bn::span<const Frame>& frames,");
        await outputFile.WriteLineAsync("    const bn::span<const Sprite>& sprites, const bn::span<const CollisionsPerFrame>& collisions_per_animation,");
        await outputFile.WriteLineAsync("    bn::ivector<bn::sprite_ptr>& currentFrameSprites) :");
        await outputFile.WriteLineAsync("    _currentAnimation(AnimationID::NONE)");
        await outputFile.WriteLineAsync("    , _frameCounter(0)");
        await outputFile.WriteLineAsync("    , _frameIndex(0)");
        await outputFile.WriteLineAsync("    , _priority(1)");
        await outputFile.WriteLineAsync("    , _z_order(1)");
        await outputFile.WriteLineAsync("    , _animation_repeats(0)");
        await outputFile.WriteLineAsync("    , _facingRight(true)");
        await outputFile.WriteLineAsync("    , _visible(true)");
        await outputFile.WriteLineAsync("    , _animations(animations)");
        await outputFile.WriteLineAsync("    , _frames(frames)");
        await outputFile.WriteLineAsync("    , _sprites(sprites)");
        await outputFile.WriteLineAsync("    , _collisions_per_animation(collisions_per_animation)");
        await outputFile.WriteLineAsync("    , _currentFrameSprites(currentFrameSprites)");
        await outputFile.WriteLineAsync("    , _animation_running(false)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::load_animation(int animation)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (animation == _currentAnimation)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _currentAnimation = animation;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameIndex = -1;");
        await outputFile.WriteLineAsync("    _animation_repeats = 0;");
        await outputFile.WriteLineAsync("    _animation_running = true;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_next_frame();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::update_animation()");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (!_animation_running)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_animations[_currentAnimation].totalFrames <= 1)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameCounter++;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_animations[_currentAnimation].frameDuration != _frameCounter)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_next_frame();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_position(int x, int y)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    bn::fixed_point position(x, y);");
        await outputFile.WriteLineAsync("    set_position(position);");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::load_next_frame()");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _frameCounter = 0;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0 || _animations[_currentAnimation].totalFrames == 0)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        _currentFrameSprites.clear();");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (++_frameIndex >= _animations[_currentAnimation].totalFrames)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        const int repeat = _animations[_currentAnimation].repeats;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        _animation_repeats++;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        if (repeat == 0 || _animation_repeats < repeat)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            _frameIndex = 0;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        else");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            --_frameIndex;");
        await outputFile.WriteLineAsync("            _animation_running = false;");
        await outputFile.WriteLineAsync("            return;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_current_frame(false);");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::load_current_frame(bool forceReload)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    int animationCount = 0;");
        await outputFile.WriteLineAsync("    int frameCount = 0;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    while (animationCount < _currentAnimation)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        frameCount += _animations[animationCount].totalFrames;");
        await outputFile.WriteLineAsync("        animationCount++;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (animationCount == _currentAnimation)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        int starts = _frames[frameCount + _frameIndex].spriteStarts;");
        await outputFile.WriteLineAsync("        int ends = _frames[frameCount + _frameIndex].spriteEnds;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        auto reload_sprites = [this](int s, int e) {");
        await outputFile.WriteLineAsync("            _currentFrameSprites.clear();");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("            for (int i = s; i <= e; ++i)");
        await outputFile.WriteLineAsync("            {");
        await outputFile.WriteLineAsync("                bn::optional<bn::sprite_ptr> sprite = create_sprite(i);");
        await outputFile.WriteLineAsync("                if (sprite.has_value())");
        await outputFile.WriteLineAsync("                    _currentFrameSprites.push_back(std::move(sprite.value()));");
        await outputFile.WriteLineAsync("            }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("            _current_sprite_start_index = s;");
        await outputFile.WriteLineAsync("        };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        if (starts >= 0)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            reload_sprites(starts, ends);");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        else if (forceReload)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            for (int nonHeldFrameIdx = _frameIndex - 1; nonHeldFrameIdx >= 0; --nonHeldFrameIdx)");
        await outputFile.WriteLineAsync("            {");
        await outputFile.WriteLineAsync("                starts = _frames[frameCount + nonHeldFrameIdx].spriteStarts;");
        await outputFile.WriteLineAsync("                ends = _frames[frameCount + nonHeldFrameIdx].spriteEnds;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("                if (starts >= 0)");
        await outputFile.WriteLineAsync("                {");
        await outputFile.WriteLineAsync("                    reload_sprites(starts, ends);");
        await outputFile.WriteLineAsync("                    break;");
        await outputFile.WriteLineAsync("                }");
        await outputFile.WriteLineAsync("            }");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_position(const bn::fixed_point& position)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _position = position;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_position(sprite.position() + position);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_camera(const bn::camera_ptr& camera)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _camera = camera;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr & sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_camera(camera);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("const bn::fixed_point& Character::position() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _position;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_z_order(int z_order)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _z_order = z_order;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_z_order(z_order);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bool Character::is_visible() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _visible;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_visible(bool visible)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _visible = visible;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_visible(visible);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_priority(int priority)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _priority = priority;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr & sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_bg_priority(priority);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_id() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _currentAnimation;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_frame_index() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _frameIndex;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_frame_counter() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _frameCounter;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_total_frames() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return -1;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animations[_currentAnimation].totalFrames;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_repeats() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return -1;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animations[_currentAnimation].repeats;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_frame_duration() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return -1;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animations[_currentAnimation].frameDuration;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bool Character::is_facing_right() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _facingRight;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bool Character::is_animation_playing() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return false;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animation_running;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bool Character::is_facing_left() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return !_facingRight;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_frame_counter(int frameCounter)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _frameCounter = frameCounter;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_frame_index(int frameIndex)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (frameIndex == _frameIndex)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameIndex = frameIndex;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_current_frame(true);");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_facing_right(bool facingRight)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_facingRight == facingRight)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _facingRight = facingRight;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    int spriteCount = 0;");
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_horizontal_flip(!_facingRight);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        if (_facingRight)");
        await outputFile.WriteLineAsync("            sprite.set_position(_position + _sprites[_current_sprite_start_index + spriteCount].position);");
        await outputFile.WriteLineAsync("        else");
        await outputFile.WriteLineAsync("            sprite.set_position(_position + _sprites[_current_sprite_start_index + spriteCount].position_horizontal_flipped);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        spriteCount++;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bn::optional<bn::sprite_ptr> Character::create_sprite(unsigned int spriteIndex)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    bn::sprite_builder builder(*_sprites[spriteIndex].sprite_item, 0);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_facingRight)");
        await outputFile.WriteLineAsync("        builder.set_position(_position + _sprites[spriteIndex].position);");
        await outputFile.WriteLineAsync("    else");
        await outputFile.WriteLineAsync("        builder.set_position(_position + _sprites[spriteIndex].position_horizontal_flipped);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    builder.set_z_order(_z_order);");
        await outputFile.WriteLineAsync("    builder.set_visible(_visible);");
        await outputFile.WriteLineAsync("    builder.set_bg_priority(_priority);");
        await outputFile.WriteLineAsync("    if (_camera.has_value())");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        builder.set_camera(_camera.value());");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("    builder.set_horizontal_flip(!_facingRight);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return builder.release_build_optional();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("auto Character::Collisions::RelativeRect::get_absolute_rect(const Character& self) const -> bn::top_left_fixed_rect");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return bn::top_left_fixed_rect(_x + self.position().x(), _y + self.position().y(), _width, _height);");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("auto Character::Collisions::get_rects_with_mask(Mask mask) const -> const bn::span<const RelativeRect>&");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    static constexpr bn::span<const RelativeRect> NULL_RECTS;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    const unsigned idx = static_cast<unsigned>(mask);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_rects_per_mask.empty())");
        await outputFile.WriteLineAsync("        return NULL_RECTS;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _rects_per_mask[idx];");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("auto Character::current_frame_collisions() const -> const Collisions&");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    static constexpr Collisions NULL_COLLISIONS{bn::span<const bn::span<const Collisions::RelativeRect>>()};");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_currentAnimation == AnimationID::NONE || _collisions_per_animation.empty())");
        await outputFile.WriteLineAsync("        return NULL_COLLISIONS;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    const auto& collisions_per_frame = _collisions_per_animation[static_cast<int>(_currentAnimation)];");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (collisions_per_frame.empty())");
        await outputFile.WriteLineAsync("        return NULL_COLLISIONS;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return collisions_per_frame[_frameIndex];");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("}");
    }
}
