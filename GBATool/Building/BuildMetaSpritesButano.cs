using ArchitectureLibrary.Model;
using GBATool.Enums;
using GBATool.FileSystem;
using GBATool.Models;
using GBATool.Utils;
using GBATool.VOs;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace GBATool.Building;

using FrameDetail = (int starts, int ends);
using SpriteDetail = (string spriteName, int xpos, int ypos, int flippedX);

public sealed class BuildMetaSpritesButano : Building<BuildMetaSpritesButano>
{
    private struct SpriteDetails
    {
        public string SpriteName;
        public string SpriteShape;
        public string SpriteSize;
        public string Tiles;
        public string TilesSize;
        public int posX;
        public int posY;
        public int FlippedPosX;
    }

    private struct FrameDetails
    {
        public string Name;
        public string BankName;
        public string BppMode;
        public string Palette;
        public string PaletteSize;
        public List<SpriteDetails> Sprites;
    }

    private struct AnimationDetails
    {
        public string Name;
        public float Speed;
        public int Priority;
        public List<FrameDetails> Frames;
    }

    protected override OutputFormat OutputFormat { get; } = OutputFormat.Butano;

    private const float FrameRate = 59.727500569606f;
    private string[]? _outputPaths;
    private readonly List<AnimationDetails> _animationDetails = [];

    protected override string[] OutputPaths
    {
        get
        {
            if (_outputPaths == null)
            {
                _outputPaths = new string[2];

                ProjectModel projectModel = ModelManager.Get<ProjectModel>();

                _outputPaths[0] = projectModel.Build.GeneratedHeadersPath;
                _outputPaths[1] = projectModel.Build.GeneratedCPPsPath;
            }

            return _outputPaths;
        }
    }

    protected override async Task<bool> DoGenerate()
    {
        string headerFolder = Path.GetFullPath(OutputPaths[0]);
        string cppFolder = Path.GetFullPath(OutputPaths[1]);

        List<FileModelVO> models = ProjectFiles.GetModels<CharacterModel>();

        foreach (FileModelVO item in models)
        {
            if (item.Model is not CharacterModel model)
            {
                continue;
            }

            if (string.IsNullOrEmpty(item.Name))
            {
                continue;
            }

            _animationDetails.Clear();

            using StreamWriter outputFileHeader = new(Path.Combine(headerFolder, item.Name + ".h"));

            await WriteSpriteFileHeader(outputFileHeader, model, item.Name);

            using StreamWriter outputFileCpp = new(Path.Combine(cppFolder, item.Name + ".cpp"));

            await WriteSpriteFileCpp(outputFileCpp, item.Name);
        }

        return GetErrors().Length == 0;
    }

    private async Task WriteSpriteFileHeader(StreamWriter outputFile, CharacterModel model, string name)
    {
        await WriteHeader(outputFile, name);
        await WriteSpritesDeclarations(outputFile, model);
        await WriteClassDeclarations(outputFile, model, name);
        await WriteFooter(outputFile, name);
    }

    private async Task WriteSpriteFileCpp(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await WriteClassDefinitions(outputFile, name);
    }

    private static async Task WriteFooter(StreamWriter outputFile, string name)
    {
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#endif // GBATOOL_SPRITE_{name.ToUpper()}");
    }

    private static async Task WriteHeader(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#ifndef GBATOOL_SPRITE_{name.ToUpper()}");
        await outputFile.WriteLineAsync($"#define GBATOOL_SPRITE_{name.ToUpper()}");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"bn_sprite_item.h\"");
        await outputFile.WriteLineAsync("#include \"bn_array.h\"");
        await outputFile.WriteLineAsync("#include \"bn_vector.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_builder.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_ptr.h\"");

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private async Task WriteSpritesDeclarations(StreamWriter outputFile, CharacterModel model)
    {
        string paletteName = string.Empty;

        foreach (KeyValuePair<string, CharacterAnimation> animationItem in model.Animations)
        {
            CharacterAnimation animation = animationItem.Value;

            if (string.IsNullOrEmpty(animation.ID))
            {
                continue;
            }

            List<FrameDetails> frame = [];

            foreach (KeyValuePair<string, FrameModel> frameItem in animation.Frames)
            {
                FrameModel frameModel = frameItem.Value;

                BankModel? bankModel = ProjectFiles.GetModel<BankModel>(frameModel.BankID);

                if (bankModel == null)
                {
                    continue;
                }

                FileModelVO? fileModelBankVO = ProjectFiles.GetFileModel(bankModel.GUID);
                if (fileModelBankVO == null)
                {
                    continue;
                }

                PaletteModel? paletteModel = CharacterUtils.GetPaletteUsedByCharacter(model);

                if (paletteModel != null)
                {
                    FileModelVO? fileModelPaletteVO = ProjectFiles.GetFileModel(paletteModel.GUID);
                    if (fileModelPaletteVO != null && string.IsNullOrEmpty(paletteName))
                    {
                        paletteName = PaletteUtils.GetPaletteName(fileModelPaletteVO) ?? string.Empty;

                        if (paletteModel.LinkedPalettes.Count > 0)
                        {
                            string remove = "_Palette_XX";

                            paletteName = paletteName.Replace(paletteName[^remove.Length..], string.Empty); // Removes the "_Palette_XX" from the name
                        }
                    }
                }

                string bankName = fileModelBankVO.Name ?? "";

                string bppMode = bankModel.Use256Colors ? "bpp_mode::BPP_8" : "bpp_mode::BPP_4";

                string palette = $"{paletteName}Pal";
                string paletteSize = bankModel.Use256Colors ? "256" : "16";

                List<SpriteDetails> spriteDetails = [];

                foreach (KeyValuePair<string, CharacterSprite> tileItem in frameModel.Tiles)
                {
                    CharacterSprite characterSprite = tileItem.Value;

                    TileSetModel? tileSetModel = ProjectFiles.GetModel<TileSetModel>(characterSprite.TileSetID);

                    if (tileSetModel == null)
                    {
                        continue;
                    }

                    SpriteModel? spriteModel = tileSetModel.Sprites.Find((item) => item.ID == characterSprite.SpriteID);

                    if (spriteModel == null)
                    {
                        continue;
                    }

                    string alias = spriteModel.Alias.Replace('-', '_');

                    int tileSizeNumber = (characterSprite.Width / 8) * (characterSprite.Height / 8);

                    tileSizeNumber *= (bankModel.Use256Colors ? 2 : 1);

                    string spriteName = $"{bankName}_{alias}";
                    string tiles = $"{bankName}_{alias}Tiles";
                    string tilesSize = $"{tileSizeNumber}";

                    int posX = (int)(characterSprite.Position.X - model.RelativeOrigin.X);
                    int posY = (int)(characterSprite.Position.Y - model.RelativeOrigin.Y);

                    int verticalAxis = model.VerticalAxis - (int)model.RelativeOrigin.X;
                    int flippedXPos = verticalAxis - (posX - verticalAxis) - characterSprite.Width;

                    // correct the origin of the metasprite
                    posX += (characterSprite.Width / 2);
                    posY += (characterSprite.Height / 2);
                    flippedXPos += (characterSprite.Width / 2);

                    SpriteShape shape = SpriteShape.Shape00;
                    SpriteSize size = SpriteSize.Size00;

                    SpriteUtils.ConvertToShapeSize(characterSprite.Width, characterSprite.Height, ref shape, ref size);

                    string spriteShape = "";

                    switch (shape)
                    {
                        case SpriteShape.Shape00: spriteShape = "sprite_shape::SQUARE"; break;
                        case SpriteShape.Shape01: spriteShape = "sprite_shape::WIDE"; break;
                        case SpriteShape.Shape10: spriteShape = "sprite_shape::TALL"; break;
                    }

                    string spriteSize = "";

                    switch (size)
                    {
                        case SpriteSize.Size00: spriteSize = "sprite_size::SMALL"; break;
                        case SpriteSize.Size01: spriteSize = "sprite_size::NORMAL"; break;
                        case SpriteSize.Size10: spriteSize = "sprite_size::BIG"; break;
                        case SpriteSize.Size11: spriteSize = "sprite_size::HUGE"; break;
                    }

                    spriteDetails.Add(new SpriteDetails()
                    {
                        SpriteName = spriteName,
                        SpriteShape = spriteShape,
                        SpriteSize = spriteSize,
                        Tiles = tiles,
                        TilesSize = tilesSize,
                        posX = posX,
                        posY = posY,
                        FlippedPosX = flippedXPos
                    });
                }

                frame.Add(new FrameDetails()
                {
                    Name = animation.Name,
                    BankName = bankName,
                    Sprites = spriteDetails,
                    BppMode = bppMode,
                    Palette = palette,
                    PaletteSize = paletteSize
                });
            }

            _animationDetails.Add(
                new AnimationDetails()
                {
                    Name = $"{animation.Name}",
                    Frames = frame,
                    Priority = (int)model.Priority,
                    Speed = animation.Speed
                });
        }

        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            foreach (FrameDetails item in animationDetail.Frames)
            {
                await outputFile.WriteLineAsync($"#include \"bank_{item.BankName}.h\"");
            }
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#include \"{paletteName}.h\"");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("namespace bn::sprite_items");
        await outputFile.WriteLineAsync("{");

        int frameIndex = 0;

        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            foreach (FrameDetails frame in animationDetail.Frames)
            {
                await outputFile.WriteLineAsync($"    // {frame.Name}_frame_{frameIndex + 1}");

                foreach (SpriteDetails sprite in frame.Sprites)
                {
                    await outputFile.WriteLineAsync($"    constexpr inline sprite_item {sprite.SpriteName}(sprite_shape_size({sprite.SpriteShape}, {sprite.SpriteSize}),");
                    await outputFile.WriteLineAsync($"           sprite_tiles_item(span<const tile>({sprite.Tiles}, {sprite.TilesSize}), {frame.BppMode}, compression_type::NONE, 1),");
                    await outputFile.WriteLineAsync($"           sprite_palette_item(span<const color>({frame.Palette}, {frame.PaletteSize}), {frame.BppMode}, compression_type::NONE));");
                }

                if (frameIndex < _animationDetails.Count)
                {
                    await outputFile.WriteAsync(Environment.NewLine);
                }

                frameIndex++;
            }
        }

        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
    }

    private async Task WriteClassDeclarations(StreamWriter outputFile, CharacterModel model, string name)
    {
        string className = name.ToCamelCase();

        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync($"    class {className};");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"class gbatool::{className}");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("public:");
        await outputFile.WriteLineAsync("    enum class AnimationID");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        NONE = -1");

        int numberMaxSpritesPerFrame = 0;
        int countSpritesTotal = 0;
        int countFramesTotal = 0;

        for (int i = 0; i < _animationDetails.Count; ++i)
        {
            await outputFile.WriteLineAsync($"        , {_animationDetails[i].Name.ToUpper()} = {i}");

            foreach (FrameDetails frame in _animationDetails[i].Frames)
            {
                if (frame.Sprites.Count > numberMaxSpritesPerFrame)
                {
                    numberMaxSpritesPerFrame = frame.Sprites.Count;
                }

                countSpritesTotal += frame.Sprites.Count;
                countFramesTotal++;
            }
        }

        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Animation");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        Animation(int total, int duration)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            totalFrames = total;");
        await outputFile.WriteLineAsync("            frameDuration = duration;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        int totalFrames;");
        await outputFile.WriteLineAsync("        int frameDuration;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Frame");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        Frame(int starts, int ends)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            spriteStarts = starts;");
        await outputFile.WriteLineAsync("            spriteEnds = ends;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        int spriteStarts;");
        await outputFile.WriteLineAsync("        int spriteEnds;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Sprite");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        Sprite(const bn::sprite_item* item, int x, int y, int xFlipped)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            sprite_item = item;");
        await outputFile.WriteLineAsync("            position = bn::fixed_point(x, y);");
        await outputFile.WriteLineAsync("            position_horizontal_flipped = bn::fixed_point(xFlipped, y);");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        const bn::sprite_item* sprite_item;");
        await outputFile.WriteLineAsync("        bn::fixed_point position;");
        await outputFile.WriteLineAsync("        bn::fixed_point position_horizontal_flipped;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"    {className}();");
        await outputFile.WriteLineAsync("    void update_animation();");
        await outputFile.WriteLineAsync("    void load_animation(AnimationID animation);");
        await outputFile.WriteLineAsync("    void set_position(int x, int y);");
        await outputFile.WriteLineAsync("    void set_position(const bn::fixed_point& position);");
        await outputFile.WriteLineAsync("    void set_camera(const bn::camera_ptr& camera);");
        await outputFile.WriteLineAsync("    void set_priority(const int priority);");
        await outputFile.WriteLineAsync("    void set_facing_right(bool facingRight);");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_facing_right() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_facing_left() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] const bn::fixed_point& position() const;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("protected:");
        await outputFile.WriteLineAsync($"    bn::vector<bn::sprite_ptr, {numberMaxSpritesPerFrame}> _currentFrameSprites;");
        await outputFile.WriteLineAsync("    bn::fixed_point _position;");
        await outputFile.WriteLineAsync("    bn::optional<bn::camera_ptr> _camera;");
        await outputFile.WriteLineAsync("    AnimationID _currentAnimation;");
        await outputFile.WriteLineAsync("    int _frameCounter;");
        await outputFile.WriteLineAsync("    int _frameIndex;");
        await outputFile.WriteLineAsync("    bool _facingRight;");
        await outputFile.WriteLineAsync($"    int _priority = {(int)model.Priority};");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("private:");
        await outputFile.WriteLineAsync("    [[nodiscard]] bn::sprite_ptr create_sprite(unsigned int spriteIndex);");
        await outputFile.WriteLineAsync("    void load_next_frame();");
        await outputFile.WriteLineAsync("    int _current_sprite_start_index;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"    static const Animation _animations[{_animationDetails.Count}];");
        await outputFile.WriteLineAsync($"    static const Frame _frames[{countFramesTotal}];");
        await outputFile.WriteLineAsync($"    static const Sprite _sprites[{countSpritesTotal}];");
        await outputFile.WriteLineAsync("};");
    }

    private async Task WriteClassDefinitions(StreamWriter outputFile, string name)
    {
        List<SpriteDetail> sprites = [];
        List<FrameDetail> frames = [];

        int acumSprites = 0;

        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            foreach (FrameDetails frame in animationDetail.Frames)
            {
                foreach (SpriteDetails sprite in frame.Sprites)
                {
                    sprites.Add((sprite.SpriteName, sprite.posX, sprite.posY, sprite.FlippedPosX));

                    acumSprites++;
                }

                frames.Add((acumSprites - frame.Sprites.Count, acumSprites - 1));
            }
        }

        string className = name.ToCamelCase();

        await outputFile.WriteLineAsync($"#include \"{name}.h\"");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteAsync($"const {className}::Animation {className}::_animations[{_animationDetails.Count}] = ");
        await outputFile.WriteAsync("{");


        for (int i = 0; i < _animationDetails.Count; ++i)
        {
            int frameDuration = (int)(_animationDetails[i].Speed * FrameRate);

            await outputFile.WriteAsync($"{{{_animationDetails[i].Frames.Count}, {frameDuration}}}");

            if (i < _animationDetails.Count - 1)
                await outputFile.WriteAsync(", ");
        }

        await outputFile.WriteLineAsync("};");
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteAsync($"const {className}::Frame {className}::_frames[{frames.Count}] = ");
        await outputFile.WriteAsync("{");

        for (int i = 0; i < frames.Count; ++i)
        {
            await outputFile.WriteAsync($"{{{frames[i].starts}, {frames[i].ends}}}");

            if (i < frames.Count - 1)
                await outputFile.WriteAsync(", ");
        }

        await outputFile.WriteLineAsync("};");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"const {className}::Sprite {className}::_sprites[{sprites.Count}] = {{");

        for (int i = 0; i < sprites.Count; ++i)
        {
            await outputFile.WriteAsync($"    {{ &bn::sprite_items::{sprites[i].spriteName}, {sprites[i].xpos}, {sprites[i].ypos}, {sprites[i].flippedX} }}");

            if (i < sprites.Count - 1)
                await outputFile.WriteAsync(",");

            await outputFile.WriteAsync(Environment.NewLine);
        }

        await outputFile.WriteLineAsync("};");

        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"{className}::{className}() :");
        await outputFile.WriteLineAsync("    _currentAnimation(AnimationID::NONE)");
        await outputFile.WriteLineAsync("    , _frameCounter(0)");
        await outputFile.WriteLineAsync("    , _frameIndex(0)");
        await outputFile.WriteLineAsync("    , _facingRight(true)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::load_animation(AnimationID animation)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (animation == _currentAnimation)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _currentAnimation = animation;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameIndex = 0;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_next_frame();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::update_animation()");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if ((int)_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_animations[(int)_currentAnimation].totalFrames <= 1)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameCounter++;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_animations[(int)_currentAnimation].frameDuration != _frameCounter)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_next_frame();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::set_position(int x, int y)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    bn::fixed_point position(x, y);");
        await outputFile.WriteLineAsync("    set_position(position);");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::load_next_frame()");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _frameCounter = 0;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _currentFrameSprites.clear();");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if ((int)_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        int animationCount = 0;");
        await outputFile.WriteLineAsync("        int frameCount = 0;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        findFrame:");
        await outputFile.WriteLineAsync("        if (animationCount == (int)_currentAnimation)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            int starts = _frames[frameCount + _frameIndex].spriteStarts;");
        await outputFile.WriteLineAsync("            int ends = _frames[frameCount + _frameIndex].spriteEnds;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("            for (int i = starts; i <= ends; ++i)");
        await outputFile.WriteLineAsync("            {");
        await outputFile.WriteLineAsync("                _currentFrameSprites.push_back(create_sprite(i));");
        await outputFile.WriteLineAsync("            }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("            _current_sprite_start_index = starts;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        else");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            frameCount += _animations[(int)animationCount].totalFrames;");
        await outputFile.WriteLineAsync("            animationCount++;");
        await outputFile.WriteLineAsync("            goto findFrame;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameIndex++;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_frameIndex >= _animations[(int)_currentAnimation].totalFrames)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        _frameIndex = 0;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::set_position(const bn::fixed_point& position)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _position = position;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_position(sprite.position() + position);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::set_camera(const bn::camera_ptr& camera)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _camera = camera;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr & sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_camera(camera);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"const bn::fixed_point& {className}::position() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _position;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::set_priority(const int priority)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _priority = priority;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr & sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_bg_priority(priority);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"bool {className}::is_facing_right() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _facingRight;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"bool {className}::is_facing_left() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return !_facingRight;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"void {className}::set_facing_right(bool facingRight)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_facingRight == facingRight)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _facingRight = facingRight;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    int spriteCount = 0;");
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_horizontal_flip(!_facingRight);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        if (_facingRight)");
        await outputFile.WriteLineAsync("            sprite.set_position(_position + _sprites[_current_sprite_start_index + spriteCount].position);");
        await outputFile.WriteLineAsync("        else");
        await outputFile.WriteLineAsync("            sprite.set_position(_position + _sprites[_current_sprite_start_index + spriteCount].position_horizontal_flipped);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        spriteCount++;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"bn::sprite_ptr {className}::create_sprite(unsigned int spriteIndex)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    bn::sprite_builder builder(*_sprites[spriteIndex].sprite_item, 0);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_facingRight)");
        await outputFile.WriteLineAsync("        builder.set_position(_position + _sprites[spriteIndex].position);");
        await outputFile.WriteLineAsync("    else");
        await outputFile.WriteLineAsync("        builder.set_position(_position + _sprites[spriteIndex].position_horizontal_flipped);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    builder.set_bg_priority(_priority);");
        await outputFile.WriteLineAsync("    if (_camera.has_value())");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        builder.set_camera(_camera.value());");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("    builder.set_horizontal_flip(!_facingRight);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return builder.release_build();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("}");
    }
}
