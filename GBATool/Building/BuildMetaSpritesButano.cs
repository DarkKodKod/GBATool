using ArchitectureLibrary.Model;
using GBATool.Enums;
using GBATool.FileSystem;
using GBATool.Models;
using GBATool.Utils;
using GBATool.VOs;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace GBATool.Building;

using FrameDetail = (int starts, int ends);
using SpriteDetail = (string spriteName, int xpos, int ypos, int flippedX);

public sealed class BuildMetaSpritesButano : Building<BuildMetaSpritesButano>
{
    private struct SpriteDetails
    {
        public string SpriteName;
        public string SpriteShape;
        public string SpriteSize;
        public string Tiles;
        public string TilesSize;
        public int posX;
        public int posY;
        public int FlippedPosX;
    }

    private struct FrameDetails
    {
        public string Name;
        public string BankName;
        public string BppMode;
        public string Palette;
        public string PaletteSize;
        public bool HeldFrame;
        public List<SpriteDetails> Sprites;
    }

    private struct AnimationDetails
    {
        public string Name;
        public float Speed;
        public int Priority;
        public bool Looping;
        public int Repeats;
        public List<FrameDetails> Frames;
    }

    protected override OutputFormat OutputFormat { get; } = OutputFormat.Butano;

    private const float FrameRate = 59.727500569606f;
    private string[]? _outputPaths;
    private readonly List<AnimationDetails> _animationDetails = [];

    protected override string[] OutputPaths
    {
        get
        {
            if (_outputPaths == null)
            {
                _outputPaths = new string[2];

                ProjectModel projectModel = ModelManager.Get<ProjectModel>();

                _outputPaths[0] = projectModel.Build.GeneratedHeadersPath;
                _outputPaths[1] = projectModel.Build.GeneratedCPPsPath;
            }

            return _outputPaths;
        }
    }

    protected override async Task<bool> DoGenerate()
    {
        string headerFolder = Util.GetAbsolutePathFromRelativeToProject(OutputPaths[0]);
        string cppFolder = Util.GetAbsolutePathFromRelativeToProject(OutputPaths[1]);

        List<FileModelVO> models = ProjectFiles.GetModels<CharacterModel>();

        {
            using StreamWriter outputBaseFileHeader = new(Path.Combine(headerFolder, "character.h"));
            using StreamWriter outputBaseFileCpp = new(Path.Combine(cppFolder, "character.cpp"));

            await WriteCharacterBaseClassHeader(outputBaseFileHeader);
            await WriteCharacterBaseClassCpp(outputBaseFileCpp);
        }

        foreach (FileModelVO item in models)
        {
            if (item.Model is not CharacterModel model)
            {
                continue;
            }

            if (string.IsNullOrEmpty(item.Name))
            {
                continue;
            }

            _animationDetails.Clear();

            using StreamWriter outputFileHeader = new(Path.Combine(headerFolder, item.Name + ".h"));

            await WriteSpriteFileHeader(outputFileHeader, model, item.Name);

            using StreamWriter outputFileCpp = new(Path.Combine(cppFolder, item.Name + ".cpp"));

            await WriteSpriteFileCpp(outputFileCpp, item.Name);
        }

        return GetErrors().Length == 0;
    }

    private async Task WriteSpriteFileHeader(StreamWriter outputFile, CharacterModel model, string name)
    {
        await WriteHeader(outputFile, name);
        await WriteSpritesDeclarations(outputFile, model);
        await WriteClassDeclarations(outputFile, model, name);
        await WriteFooter(outputFile, name);
    }

    private async Task WriteSpriteFileCpp(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await WriteClassDefinitions(outputFile, name);
    }

    private static async Task WriteFooter(StreamWriter outputFile, string name)
    {
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#endif // GBATOOL_SPRITE_{name.ToUpper()}");
    }

    private static async Task WriteHeader(StreamWriter outputFile, string name)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#ifndef GBATOOL_SPRITE_{name.ToUpper()}");
        await outputFile.WriteLineAsync($"#define GBATOOL_SPRITE_{name.ToUpper()}");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"bn_sprite_item.h\"");
        await outputFile.WriteLineAsync("#include \"bn_array.h\"");
        await outputFile.WriteLineAsync("#include \"bn_vector.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_builder.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_ptr.h\"");

        await outputFile.WriteAsync(Environment.NewLine);
    }

    private async Task WriteSpritesDeclarations(StreamWriter outputFile, CharacterModel characterModel)
    {
        string paletteName = string.Empty;
        List<string> alreadyUsedDeclaration = [];

        PaletteModel? paletteModel = CharacterUtils.GetPaletteUsedByCharacter(characterModel);

        if (paletteModel != null)
        {
            FileModelVO? fileModelPaletteVO = ProjectFiles.GetFileModel(paletteModel.GUID);
            if (fileModelPaletteVO != null && string.IsNullOrEmpty(paletteName))
            {
                paletteName = PaletteUtils.GetPaletteName(fileModelPaletteVO) ?? string.Empty;

                if (paletteModel.LinkedPalettes.Count > 0)
                {
                    string remove = "_Palette_XX";

                    paletteName = paletteName.Replace(paletteName[^remove.Length..], string.Empty); // Removes the "_Palette_XX" from the name
                }
            }
        }

        foreach (KeyValuePair<string, CharacterAnimation> animationItem in characterModel.Animations)
        {
            CharacterAnimation animation = animationItem.Value;

            if (string.IsNullOrEmpty(animation.ID))
            {
                continue;
            }

            List<FrameDetails> frames = [];

            foreach (KeyValuePair<string, FrameModel> frameItem in animation.Frames)
            {
                FrameModel frameModel = frameItem.Value;

                if (frameModel.IsHeldFrame)
                {
                    frames.Add(new FrameDetails()
                    {
                        Name = animation.Name,
                        HeldFrame = true,
                        BankName = string.Empty,
                        Sprites = [],
                        BppMode = string.Empty,
                        Palette = string.Empty,
                        PaletteSize = string.Empty
                    });
                    continue;
                }

                BankModel? bankModel = ProjectFiles.GetModel<BankModel>(frameModel.BankID);

                if (bankModel == null)
                {
                    continue;
                }

                FileModelVO? fileModelBankVO = ProjectFiles.GetFileModel(bankModel.GUID);
                if (fileModelBankVO == null)
                {
                    continue;
                }

                string bankName = fileModelBankVO.Name ?? "";
                string bppMode = bankModel.BitsPerPixel == BitsPerPixel.f8bpp ? "bpp_mode::BPP_8" : "bpp_mode::BPP_4";
                string palette = $"{paletteName}Pal";
                string paletteSize = bankModel.BitsPerPixel == BitsPerPixel.f8bpp ? "256" : "16";

                List<SpriteDetails> spriteDetails = [];

                foreach (KeyValuePair<string, CharacterSprite> tileItem in frameModel.Tiles)
                {
                    CharacterSprite characterSprite = tileItem.Value;

                    TileSetModel? tileSetModel = ProjectFiles.GetModel<TileSetModel>(characterSprite.TileSetID);

                    if (tileSetModel == null)
                    {
                        continue;
                    }

                    SpriteModel? spriteModel = tileSetModel.Sprites.Find((item) => item.ID == characterSprite.SpriteID);

                    if (spriteModel == null)
                    {
                        continue;
                    }

                    string alias = spriteModel.Alias.Replace('-', '_');

                    int tileSizeNumber = (characterSprite.Width / 8) * (characterSprite.Height / 8);

                    tileSizeNumber *= (bankModel.BitsPerPixel == BitsPerPixel.f8bpp ? 2 : 1);

                    string spriteName = $"{bankName}_{alias}";
                    string tiles = $"{bankName}_{alias}Tiles";
                    string tilesSize = $"{tileSizeNumber}";

                    int posX = (int)(characterSprite.Position.X - characterModel.RelativeOrigin.X);
                    int posY = (int)(characterSprite.Position.Y - characterModel.RelativeOrigin.Y);

                    int verticalAxis = characterModel.VerticalAxis - (int)characterModel.RelativeOrigin.X;
                    int flippedXPos = verticalAxis - (posX - verticalAxis) - characterSprite.Width;

                    // correct the origin of the metasprite
                    posX += (characterSprite.Width / 2);
                    posY += (characterSprite.Height / 2);
                    flippedXPos += (characterSprite.Width / 2);

                    SpriteShape shape = SpriteShape.Shape00;
                    SpriteSize size = SpriteSize.Size00;

                    SpriteUtils.ConvertToShapeSize(characterSprite.Width, characterSprite.Height, ref shape, ref size);

                    string spriteShape = "";

                    switch (shape)
                    {
                        case SpriteShape.Shape00: spriteShape = "sprite_shape::SQUARE"; break;
                        case SpriteShape.Shape01: spriteShape = "sprite_shape::WIDE"; break;
                        case SpriteShape.Shape10: spriteShape = "sprite_shape::TALL"; break;
                    }

                    string spriteSize = "";

                    switch (size)
                    {
                        case SpriteSize.Size00: spriteSize = "sprite_size::SMALL"; break;
                        case SpriteSize.Size01: spriteSize = "sprite_size::NORMAL"; break;
                        case SpriteSize.Size10: spriteSize = "sprite_size::BIG"; break;
                        case SpriteSize.Size11: spriteSize = "sprite_size::HUGE"; break;
                    }

                    spriteDetails.Add(new SpriteDetails()
                    {
                        SpriteName = spriteName,
                        SpriteShape = spriteShape,
                        SpriteSize = spriteSize,
                        Tiles = tiles,
                        TilesSize = tilesSize,
                        posX = posX,
                        posY = posY,
                        FlippedPosX = flippedXPos
                    });
                }

                frames.Add(new FrameDetails()
                {
                    Name = animation.Name,
                    BankName = bankName,
                    Sprites = spriteDetails,
                    BppMode = bppMode,
                    Palette = palette,
                    HeldFrame = false,
                    PaletteSize = paletteSize
                });
            }

            _animationDetails.Add(
                new AnimationDetails()
                {
                    Name = $"{animation.Name}",
                    Frames = frames,
                    Priority = (int)characterModel.Priority,
                    Looping = animation.Looping,
                    Repeats = animation.Repeat,
                    Speed = animation.Speed
                });
        }

        List<string> includeBankUsed = [];
        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            foreach (FrameDetails item in animationDetail.Frames)
            {
                if (item.HeldFrame)
                    continue;

                if (!includeBankUsed.Contains(item.BankName))
                {
                    await outputFile.WriteLineAsync($"#include \"bank_{item.BankName}.h\"");

                    includeBankUsed.Add(item.BankName);
                }
            }
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"#include \"{paletteName}.h\"");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"character.h\"");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("namespace bn::sprite_items");
        await outputFile.WriteLineAsync("{");

        int countAnimations = 0;

        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            int frameIndex = 0;

            foreach (FrameDetails frame in animationDetail.Frames)
            {
                string heldFrame = frame.HeldFrame ? " - Held Frame" : string.Empty;

                await outputFile.WriteLineAsync($"    // {frame.Name}_frame_{frameIndex + 1}{heldFrame}");

                foreach (SpriteDetails sprite in frame.Sprites)
                {
                    if (!alreadyUsedDeclaration.Exists(x => x == sprite.SpriteName))
                    {
                        await outputFile.WriteLineAsync($"    constexpr inline sprite_item {sprite.SpriteName}(sprite_shape_size({sprite.SpriteShape}, {sprite.SpriteSize}),");
                        await outputFile.WriteLineAsync($"           sprite_tiles_item(span<const tile>({sprite.Tiles}, {sprite.TilesSize}), {frame.BppMode}, compression_type::NONE, 1),");
                        await outputFile.WriteLineAsync($"           sprite_palette_item(span<const color>({frame.Palette}, {frame.PaletteSize}), {frame.BppMode}, compression_type::NONE));");

                        alreadyUsedDeclaration.Add(sprite.SpriteName);
                    }
                    else
                    {
                        await outputFile.WriteLineAsync($"    // sprite_item, {sprite.SpriteName}, already declared in a previous frame");
                    }
                }

                frameIndex++;

                if (frameIndex < animationDetail.Frames.Count)
                {
                    await outputFile.WriteAsync(Environment.NewLine);
                }
            }

            countAnimations++;

            if (countAnimations < _animationDetails.Count)
            {
                await outputFile.WriteAsync(Environment.NewLine);
            }
        }

        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
    }

    private async Task WriteClassDeclarations(StreamWriter outputFile, CharacterModel model, string name)
    {
        string className = name.ToCamelCase();

        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync($"    class {className};");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"class gbatool::{className} : public Character");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("public:");
        await outputFile.WriteLineAsync("    enum AnimationID");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        NONE = Character::AnimationID::NONE");

        int numberMaxSpritesPerFrame = 0;
        int countSpritesTotal = 0;
        int countFramesTotal = 0;

        for (int i = 0; i < _animationDetails.Count; ++i)
        {
            await outputFile.WriteLineAsync($"        , {_animationDetails[i].Name.ToUpper()} = {i}");

            foreach (FrameDetails frame in _animationDetails[i].Frames)
            {
                if (frame.Sprites.Count > numberMaxSpritesPerFrame)
                {
                    numberMaxSpritesPerFrame = frame.Sprites.Count;
                }

                countSpritesTotal += frame.Sprites.Count;
                countFramesTotal++;
            }
        }

        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"    {className}();");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("protected:");
        await outputFile.WriteLineAsync($"    bn::vector<bn::sprite_ptr, {numberMaxSpritesPerFrame}> _frameSprites;");
        await outputFile.WriteLineAsync("};");
    }

    private async Task WriteClassDefinitions(StreamWriter outputFile, string name)
    {
        List<SpriteDetail> sprites = [];
        List<FrameDetail> frames = [];

        int acumSprites = 0;

        foreach (AnimationDetails animationDetail in _animationDetails)
        {
            foreach (FrameDetails frame in animationDetail.Frames)
            {
                foreach (SpriteDetails sprite in frame.Sprites)
                {
                    sprites.Add((sprite.SpriteName, sprite.posX, sprite.posY, sprite.FlippedPosX));

                    acumSprites++;
                }

                if (frame.HeldFrame)
                {
                    frames.Add((-1, -1));
                }
                else
                {
                    frames.Add((acumSprites - frame.Sprites.Count, acumSprites - 1));
                }
            }
        }

        string className = name.ToCamelCase();

        await outputFile.WriteLineAsync($"#include \"{name}.h\"");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteAsync($"static constexpr {className}::Animation animations[{_animationDetails.Count}] = ");
        await outputFile.WriteAsync("{");

        for (int i = 0; i < _animationDetails.Count; ++i)
        {
            int frameDuration = (int)(_animationDetails[i].Speed * FrameRate);
            int repeats = _animationDetails[i].Looping ? 0 : _animationDetails[i].Repeats;

            await outputFile.WriteAsync($"{{{_animationDetails[i].Frames.Count}, {frameDuration}, {repeats}}}");

            if (i < _animationDetails.Count - 1)
                await outputFile.WriteAsync(", ");
        }

        await outputFile.WriteLineAsync("};");
        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteAsync($"static constexpr {className}::Frame frames[{frames.Count}] = ");
        await outputFile.WriteAsync("{");

        for (int i = 0; i < frames.Count; ++i)
        {
            await outputFile.WriteAsync($"{{{frames[i].starts}, {frames[i].ends}}}");

            if (i < frames.Count - 1)
                await outputFile.WriteAsync(", ");
        }

        await outputFile.WriteLineAsync("};");

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync($"static constexpr {className}::Sprite sprites[{sprites.Count}] = {{");

        for (int i = 0; i < sprites.Count; ++i)
        {
            await outputFile.WriteAsync($"    {{ &bn::sprite_items::{sprites[i].spriteName}, {sprites[i].xpos}, {sprites[i].ypos}, {sprites[i].flippedX} }}");

            if (i < sprites.Count - 1)
                await outputFile.WriteAsync(",");

            await outputFile.WriteAsync(Environment.NewLine);
        }

        await outputFile.WriteLineAsync("};");

        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync($"{className}::{className}() :");
        await outputFile.WriteLineAsync("    Character(");
        await outputFile.WriteLineAsync($"        bn::span<const {className}::Animation>(animations, {_animationDetails.Count}), ");
        await outputFile.WriteLineAsync($"        bn::span<const {className}::Frame>(frames, {frames.Count}), ");
        await outputFile.WriteLineAsync($"        bn::span<const {className}::Sprite>(sprites, {sprites.Count}),");
        await outputFile.WriteLineAsync("        _frameSprites");
        await outputFile.WriteLineAsync("    )");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("}");
    }

    private async static Task WriteCharacterBaseClassHeader(StreamWriter outputFile)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#ifndef GBATOOL_CHARACTER");
        await outputFile.WriteLineAsync("#define GBATOOL_CHARACTER");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("#include \"bn_sprite_item.h\"");
        await outputFile.WriteLineAsync("#include \"bn_array.h\"");
        await outputFile.WriteLineAsync("#include \"bn_vector.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_builder.h\"");
        await outputFile.WriteLineAsync("#include \"bn_sprite_ptr.h\"");
        await outputFile.WriteLineAsync("#include \"bn_span.h\"");
        await outputFile.WriteLineAsync("#include \"bn_optional.h\"");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("class Character");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("public:");
        await outputFile.WriteLineAsync("    enum AnimationID");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        NONE = -1");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Animation");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        constexpr Animation(int total, int duration, int rep) :");
        await outputFile.WriteLineAsync("            totalFrames(total)");
        await outputFile.WriteLineAsync("            , frameDuration(duration)");
        await outputFile.WriteLineAsync("            , repeats(rep)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        int totalFrames;");
        await outputFile.WriteLineAsync("        int frameDuration;");
        await outputFile.WriteLineAsync("        int repeats;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Frame");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        constexpr Frame(int starts, int ends) :");
        await outputFile.WriteLineAsync("            spriteStarts(starts)");
        await outputFile.WriteLineAsync("            , spriteEnds(ends)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        int spriteStarts;");
        await outputFile.WriteLineAsync("        int spriteEnds;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    struct Sprite");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        constexpr Sprite(const bn::sprite_item* item, int x, int y, int xFlipped) : ");
        await outputFile.WriteLineAsync("            sprite_item(item)");
        await outputFile.WriteLineAsync("            , position(bn::fixed_point(x, y))");
        await outputFile.WriteLineAsync("            , position_horizontal_flipped(bn::fixed_point(xFlipped, y))");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        const bn::sprite_item* sprite_item;");
        await outputFile.WriteLineAsync("        bn::fixed_point position;");
        await outputFile.WriteLineAsync("        bn::fixed_point position_horizontal_flipped;");
        await outputFile.WriteLineAsync("    };");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    virtual ~Character() = default;");
        await outputFile.WriteLineAsync("    void update_animation();");
        await outputFile.WriteLineAsync("    void load_animation(int animation);");
        await outputFile.WriteLineAsync("    void set_position(int x, int y);");
        await outputFile.WriteLineAsync("    void set_position(const bn::fixed_point& position);");
        await outputFile.WriteLineAsync("    void set_camera(const bn::camera_ptr& camera);");
        await outputFile.WriteLineAsync("    void set_priority(const int priority);");
        await outputFile.WriteLineAsync("    void set_facing_right(bool facingRight);");
        await outputFile.WriteLineAsync("    void set_frame_counter(int frameCounter);");
        await outputFile.WriteLineAsync("    void set_frame_index(int frameIndex);");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_facing_right() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_facing_left() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] bool is_animation_playing() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_frame_index() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_frame_counter() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_total_frames() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_frame_duration() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] int current_animation_repeats() const;");
        await outputFile.WriteLineAsync("    [[nodiscard]] const bn::fixed_point& position() const;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("protected:");
        await outputFile.WriteLineAsync("    Character(const bn::span<const Animation>& animations, const bn::span<const Frame>& frames, const bn::span<const Sprite>& sprites, bn::ivector<bn::sprite_ptr>& currentFrameSprites);");
        await outputFile.WriteLineAsync("    Character(const Character&) = delete;");
        await outputFile.WriteLineAsync("    Character(const Character&&) = delete;");
        await outputFile.WriteLineAsync("    bn::fixed_point _position;");
        await outputFile.WriteLineAsync("    bn::optional<bn::camera_ptr> _camera;");
        await outputFile.WriteLineAsync("    int _currentAnimation;");
        await outputFile.WriteLineAsync("    int _frameCounter;");
        await outputFile.WriteLineAsync("    int _frameIndex;");
        await outputFile.WriteLineAsync("    bool _facingRight;");
        await outputFile.WriteLineAsync("    int _priority = 1;");
        await outputFile.WriteLineAsync("    int _animation_repeats;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("private:");
        await outputFile.WriteLineAsync("    [[nodiscard]] bn::optional<bn::sprite_ptr> create_sprite(unsigned int spriteIndex);");
        await outputFile.WriteLineAsync("    void load_next_frame();");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    bn::span<const Animation> _animations;");
        await outputFile.WriteLineAsync("    bn::span<const Frame> _frames;");
        await outputFile.WriteLineAsync("    bn::span<const Sprite> _sprites;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    bn::ivector<bn::sprite_ptr>& _currentFrameSprites;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    int _current_sprite_start_index;");
        await outputFile.WriteLineAsync("    bool _animation_running;");
        await outputFile.WriteLineAsync("};");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("#endif // GBATOOL_CHARACTER");
    }

    private async static Task WriteCharacterBaseClassCpp(StreamWriter outputFile)
    {
        List<string> header = Util.GetAutoGeneratedHeaderInfo("//");

        foreach (string item in header)
        {
            await outputFile.WriteLineAsync(item);
        }

        await outputFile.WriteAsync(Environment.NewLine);

        await outputFile.WriteLineAsync("#include \"character.h\"");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("namespace gbatool");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("Character::Character(const bn::span<const Animation>& animations, const bn::span<const Frame>& frames, const bn::span<const Sprite>& sprites, bn::ivector<bn::sprite_ptr>& currentFrameSprites) :");
        await outputFile.WriteLineAsync("    _currentAnimation(AnimationID::NONE)");
        await outputFile.WriteLineAsync("    , _frameCounter(0)");
        await outputFile.WriteLineAsync("    , _frameIndex(0)");
        await outputFile.WriteLineAsync("    , _facingRight(true)");
        await outputFile.WriteLineAsync("    , _animation_repeats(0)");
        await outputFile.WriteLineAsync("    , _animations(animations)");
        await outputFile.WriteLineAsync("    , _frames(frames)");
        await outputFile.WriteLineAsync("    , _sprites(sprites)");
        await outputFile.WriteLineAsync("    , _currentFrameSprites(currentFrameSprites)");
        await outputFile.WriteLineAsync("    , _animation_running(false)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::load_animation(int animation)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (animation == _currentAnimation)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _currentAnimation = animation;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameIndex = 0;");
        await outputFile.WriteLineAsync("    _animation_repeats = 0;");
        await outputFile.WriteLineAsync("    _animation_running = true;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_next_frame();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::update_animation()");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (!_animation_running)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_animations[_currentAnimation].totalFrames <= 1)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameCounter++;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_animations[_currentAnimation].frameDuration != _frameCounter)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    load_next_frame();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_position(int x, int y)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    bn::fixed_point position(x, y);");
        await outputFile.WriteLineAsync("    set_position(position);");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::load_next_frame()");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _frameCounter = 0;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        _currentFrameSprites.clear();");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        int animationCount = 0;");
        await outputFile.WriteLineAsync("        int frameCount = 0;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        findFrame:");
        await outputFile.WriteLineAsync("        if (animationCount == _currentAnimation)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            int starts = _frames[frameCount + _frameIndex].spriteStarts;");
        await outputFile.WriteLineAsync("            int ends = _frames[frameCount + _frameIndex].spriteEnds;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("            if (starts >= 0)");
        await outputFile.WriteLineAsync("            {");
        await outputFile.WriteLineAsync("                _currentFrameSprites.clear();");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("                for (int i = starts; i <= ends; ++i)");
        await outputFile.WriteLineAsync("                {");
        await outputFile.WriteLineAsync("                    bn::optional<bn::sprite_ptr> sprite = create_sprite(i);");
        await outputFile.WriteLineAsync("                    if (sprite.has_value())");
        await outputFile.WriteLineAsync("                        _currentFrameSprites.push_back(std::move(sprite.value()));");
        await outputFile.WriteLineAsync("                }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("                _current_sprite_start_index = starts;");
        await outputFile.WriteLineAsync("            }");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        else");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            frameCount += _animations[animationCount].totalFrames;");
        await outputFile.WriteLineAsync("            animationCount++;");
        await outputFile.WriteLineAsync("            goto findFrame;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _frameIndex++;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_frameIndex >= _animations[_currentAnimation].totalFrames)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        const int repeat = _animations[_currentAnimation].repeats;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        _animation_repeats++;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        if (repeat == 0 || _animation_repeats < repeat)");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            _frameIndex = 0;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("        else");
        await outputFile.WriteLineAsync("        {");
        await outputFile.WriteLineAsync("            _animation_running = false;");
        await outputFile.WriteLineAsync("        }");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_position(const bn::fixed_point& position)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _position = position;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_position(sprite.position() + position);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_camera(const bn::camera_ptr& camera)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _camera = camera;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr & sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_camera(camera);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("const bn::fixed_point& Character::position() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _position;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_priority(const int priority)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _priority = priority;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr & sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_bg_priority(priority);");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_frame_index() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _frameIndex;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_frame_counter() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _frameCounter;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_total_frames() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return -1;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animations[_currentAnimation].totalFrames;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_repeats() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return -1;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animations[_currentAnimation].repeats;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("int Character::current_animation_frame_duration() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return -1;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animations[_currentAnimation].frameDuration;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bool Character::is_facing_right() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return _facingRight;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bool Character::is_animation_playing() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_currentAnimation < 0)");
        await outputFile.WriteLineAsync("        return false;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return _animation_running;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bool Character::is_facing_left() const");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    return !_facingRight;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_frame_counter(int frameCounter)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _frameCounter = frameCounter;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_frame_index(int frameIndex)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    _frameIndex = frameIndex;");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("void Character::set_facing_right(bool facingRight)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    if (_facingRight == facingRight)");
        await outputFile.WriteLineAsync("        return;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    _facingRight = facingRight;");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    int spriteCount = 0;");
        await outputFile.WriteLineAsync("    for (bn::sprite_ptr& sprite : _currentFrameSprites)");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        sprite.set_horizontal_flip(!_facingRight);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        if (_facingRight)");
        await outputFile.WriteLineAsync("            sprite.set_position(_position + _sprites[_current_sprite_start_index + spriteCount].position);");
        await outputFile.WriteLineAsync("        else");
        await outputFile.WriteLineAsync("            sprite.set_position(_position + _sprites[_current_sprite_start_index + spriteCount].position_horizontal_flipped);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("        spriteCount++;");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("bn::optional<bn::sprite_ptr> Character::create_sprite(unsigned int spriteIndex)");
        await outputFile.WriteLineAsync("{");
        await outputFile.WriteLineAsync("    bn::sprite_builder builder(*_sprites[spriteIndex].sprite_item, 0);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    if (_facingRight)");
        await outputFile.WriteLineAsync("        builder.set_position(_position + _sprites[spriteIndex].position);");
        await outputFile.WriteLineAsync("    else");
        await outputFile.WriteLineAsync("        builder.set_position(_position + _sprites[spriteIndex].position_horizontal_flipped);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    builder.set_bg_priority(_priority);");
        await outputFile.WriteLineAsync("    if (_camera.has_value())");
        await outputFile.WriteLineAsync("    {");
        await outputFile.WriteLineAsync("        builder.set_camera(_camera.value());");
        await outputFile.WriteLineAsync("    }");
        await outputFile.WriteLineAsync("    builder.set_horizontal_flip(!_facingRight);");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("    return builder.release_build_optional();");
        await outputFile.WriteLineAsync("}");
        await outputFile.WriteAsync(Environment.NewLine);
        await outputFile.WriteLineAsync("}");
    }
}
