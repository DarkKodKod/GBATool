using ArchitectureLibrary.Model;
using GBATool.FileSystem;
using GBATool.Models;
using GBATool.VOs;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

namespace GBATool.Building;

public sealed class BuildMetaSprites : Building<BuildMetaSprites>
{
    protected override string FileName { get; } = string.Empty;

    private const float FrameRate = 59.727500569606f;

    protected override async Task<bool> DoGenerate()
    {
        ProjectModel projectModel = ModelManager.Get<ProjectModel>();

        List<FileModelVO> models = ProjectFiles.GetModels<CharacterModel>();

        foreach (FileModelVO item in models)
        {
            if (item.Model is not CharacterModel model)
            {
                continue;
            }

            if (string.IsNullOrEmpty(item.Name))
            {
                continue;
            }

            string fullPath = Path.Combine(Path.GetFullPath(projectModel.Build.GeneratedAssetsPath), item.Name + ".asm");

            using StreamWriter outputFile = new(fullPath);

            await WriteMetaSpriteHeader(outputFile);
            await WriteMetaSprites(outputFile, model, item.Name);
        }

        return GetErrors().Length == 0;
    }

    private static async Task WriteMetaSpriteHeader(StreamWriter outputFile)
    {
        await outputFile.WriteLineAsync("; This file is autogenerated!");
        await outputFile.WriteAsync(Environment.NewLine);
        //        outputFile.WriteLine("; PPU OAM");
        //        outputFile.WriteLine("; http://wiki.nesdev.com/w/index.php/PPU_OAM");
        //        outputFile.WriteLine("");
        //        outputFile.WriteLine("; Byte 0 - Y position of top of sprite");
        //        outputFile.WriteLine("; Byte 1 - Tile index number");
        //        outputFile.WriteLine("; Byte 2 - Attributes");
        //        outputFile.WriteLine(";           76543210");
        //        outputFile.WriteLine(";           ||||||||");
        //        outputFile.WriteLine(";           ||||||++- Palette (4 to 7) of sprite");
        //        outputFile.WriteLine(";           |||+++--- Unimplemented");
        //        outputFile.WriteLine(";           ||+------ Priority (0: in front of background; 1: behind background)");
        //        outputFile.WriteLine(";           |+------- Flip sprite horizontally");
        //        outputFile.WriteLine(";           +-------- Flip sprite vertically");
        //        outputFile.WriteLine("; Byte 3 - X position of left side of sprite.");
        //        await outputFile.WriteAsync(Environment.NewLine);
    }

    private static async Task WriteMetaSprites(StreamWriter outputFile, CharacterModel model, string name)
    {
        List<string> animationIndices = [];

        foreach (KeyValuePair<string, CharacterAnimation> animationItem in model.Animations)
        {
            CharacterAnimation animation = animationItem.Value;

            if (string.IsNullOrEmpty(animation.ID))
            {
                continue;
            }

            int frameIndex = 0;
            List<string> frameNames = [];

            foreach (KeyValuePair<string, FrameModel> frameItem in animation.Frames)
            {
                FrameModel frameModel = frameItem.Value;

                BankModel? bankModel = ProjectFiles.GetModel<BankModel>(frameModel.BankID);

                if (bankModel == null)
                {
                    continue;
                }

                string frameName = $"{name}_{animation.Name}_frame_{frameIndex}";
                bool foundFrame = false;

                foreach (KeyValuePair<string, CharacterSprite> tileItem in frameModel.Tiles)
                {
                    CharacterSprite sprite = tileItem.Value;

                    if (foundFrame == false)
                    {
                        frameNames.Add(frameName);

                        await outputFile.WriteLineAsync("    align 4");
                        await outputFile.WriteLineAsync($"{frameName}:");

                        foundFrame = true;
                        frameIndex++;
                    }

                    byte horiz = (byte)sprite.Position.X;
                    byte vert = (byte)sprite.Position.Y;
                    byte tile = (byte)bankModel.GetTileIndex(sprite.SpriteID);

                    int paletteIndex = model.PaletteIndex;

                    byte attrs = (byte)paletteIndex;
                    attrs |= sprite.FlipX ? (byte)64 : (byte)0;
                    attrs |= sprite.FlipY ? (byte)128 : (byte)0;

                    await outputFile.WriteLineAsync($"    dw (ATTR_0_SPRITE_SIZE_00 or 0000000001100100b)");
                }

                if (foundFrame)
                {
                    await outputFile.WriteAsync(Environment.NewLine);
                }
            }

            await outputFile.WriteLineAsync("    align 1");
            await outputFile.WriteLineAsync($"{name}_{animation.Name}_data:");

            animationIndices.Add($"{animation.Name}");

            int frameDuration = (int)(animation.Speed * FrameRate);

            await outputFile.WriteLineAsync($"    ; number of frames");
            await outputFile.WriteLineAsync($"    db ${frameNames.Count:X2} ; decimal {frameNames.Count}");
            await outputFile.WriteLineAsync($"    ; frame duration");
            await outputFile.WriteLineAsync($"    db ${frameDuration:X2} ; decimal {frameDuration}");

            // TODO: Write collision info here

            if (frameNames.Count > 0)
            {
                await outputFile.WriteLineAsync("    align 4");

                foreach (string frameName in frameNames)
                {
                    await outputFile.WriteLineAsync($"    dw {frameName}");
                }
            }

            await outputFile.WriteAsync(Environment.NewLine);
        }

        if (animationIndices.Count > 0)
        {
            await outputFile.WriteLineAsync("; aninmation indices");

            for (int i = 0; i < animationIndices.Count; ++i)
            {
                string index = animationIndices[i].ToUpper();
                string nameUpper = name.ToUpper();

                await outputFile.WriteLineAsync($"ANIM_{nameUpper}_{index} = ${i:X2}");
            }

            await outputFile.WriteAsync(Environment.NewLine);
            await outputFile.WriteLineAsync("    align 4");
            await outputFile.WriteLineAsync($"{name}_anim_num_map:");

            for (int i = 0; i < animationIndices.Count; ++i)
            {
                string index = animationIndices[i];

                await outputFile.WriteLineAsync($"    dw {name}_{index}_data");
            }
        }
    }
}
